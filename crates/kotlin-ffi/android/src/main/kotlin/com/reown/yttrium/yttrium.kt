// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

@file:Suppress("NAME_SHADOWING")

package uniffi.yttrium

// Common helper code.
//
// Ideally this would live in a separate .kt file where it can be unittested etc
// in isolation, and perhaps even published as a re-useable package.
//
// However, it's important that the details of how this helper code works (e.g. the
// way that different builtin types are passed across the FFI) exactly match what's
// expected by the Rust code on the other side of the interface. In practice right
// now that means coming from the exact some version of `uniffi` that was used to
// compile the Rust component. The easiest way to ensure this is to bundle the Kotlin
// helpers directly inline like we're doing here.

import com.sun.jna.Library
import com.sun.jna.IntegerType
import com.sun.jna.Native
import com.sun.jna.Pointer
import com.sun.jna.Structure
import com.sun.jna.Callback
import com.sun.jna.ptr.*
import java.nio.ByteBuffer
import java.nio.ByteOrder
import java.nio.CharBuffer
import java.nio.charset.CodingErrorAction
import java.util.concurrent.atomic.AtomicLong
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.atomic.AtomicBoolean
import kotlin.coroutines.resume
import kotlinx.coroutines.CancellableContinuation
import kotlinx.coroutines.DelicateCoroutinesApi
import kotlinx.coroutines.GlobalScope
import kotlinx.coroutines.Job
import kotlinx.coroutines.launch
import kotlinx.coroutines.suspendCancellableCoroutine

// This is a helper for safely working with byte buffers returned from the Rust code.
// A rust-owned buffer is represented by its capacity, its current length, and a
// pointer to the underlying data.

/**
 * @suppress
 */
@Structure.FieldOrder("capacity", "len", "data")
open class RustBuffer : Structure() {
    // Note: `capacity` and `len` are actually `ULong` values, but JVM only supports signed values.
    // When dealing with these fields, make sure to call `toULong()`.
    @JvmField var capacity: Long = 0
    @JvmField var len: Long = 0
    @JvmField var data: Pointer? = null

    class ByValue: RustBuffer(), Structure.ByValue
    class ByReference: RustBuffer(), Structure.ByReference

   internal fun setValue(other: RustBuffer) {
        capacity = other.capacity
        len = other.len
        data = other.data
    }

    companion object {
        internal fun alloc(size: ULong = 0UL) = uniffiRustCall() { status ->
            // Note: need to convert the size to a `Long` value to make this work with JVM.
            UniffiLib.INSTANCE.ffi_yttrium_rustbuffer_alloc(size.toLong(), status)
        }.also {
            if(it.data == null) {
               throw RuntimeException("RustBuffer.alloc() returned null data pointer (size=${size})")
           }
        }

        internal fun create(capacity: ULong, len: ULong, data: Pointer?): RustBuffer.ByValue {
            var buf = RustBuffer.ByValue()
            buf.capacity = capacity.toLong()
            buf.len = len.toLong()
            buf.data = data
            return buf
        }

        internal fun free(buf: RustBuffer.ByValue) = uniffiRustCall() { status ->
            UniffiLib.INSTANCE.ffi_yttrium_rustbuffer_free(buf, status)
        }
    }

    @Suppress("TooGenericExceptionThrown")
    fun asByteBuffer() =
        this.data?.getByteBuffer(0, this.len.toLong())?.also {
            it.order(ByteOrder.BIG_ENDIAN)
        }
}

/**
 * The equivalent of the `*mut RustBuffer` type.
 * Required for callbacks taking in an out pointer.
 *
 * Size is the sum of all values in the struct.
 *
 * @suppress
 */
class RustBufferByReference : ByReference(16) {
    /**
     * Set the pointed-to `RustBuffer` to the given value.
     */
    fun setValue(value: RustBuffer.ByValue) {
        // NOTE: The offsets are as they are in the C-like struct.
        val pointer = getPointer()
        pointer.setLong(0, value.capacity)
        pointer.setLong(8, value.len)
        pointer.setPointer(16, value.data)
    }

    /**
     * Get a `RustBuffer.ByValue` from this reference.
     */
    fun getValue(): RustBuffer.ByValue {
        val pointer = getPointer()
        val value = RustBuffer.ByValue()
        value.writeField("capacity", pointer.getLong(0))
        value.writeField("len", pointer.getLong(8))
        value.writeField("data", pointer.getLong(16))

        return value
    }
}

// This is a helper for safely passing byte references into the rust code.
// It's not actually used at the moment, because there aren't many things that you
// can take a direct pointer to in the JVM, and if we're going to copy something
// then we might as well copy it into a `RustBuffer`. But it's here for API
// completeness.

@Structure.FieldOrder("len", "data")
internal open class ForeignBytes : Structure() {
    @JvmField var len: Int = 0
    @JvmField var data: Pointer? = null

    class ByValue : ForeignBytes(), Structure.ByValue
}
/**
 * The FfiConverter interface handles converter types to and from the FFI
 *
 * All implementing objects should be public to support external types.  When a
 * type is external we need to import it's FfiConverter.
 *
 * @suppress
 */
public interface FfiConverter<KotlinType, FfiType> {
    // Convert an FFI type to a Kotlin type
    fun lift(value: FfiType): KotlinType

    // Convert an Kotlin type to an FFI type
    fun lower(value: KotlinType): FfiType

    // Read a Kotlin type from a `ByteBuffer`
    fun read(buf: ByteBuffer): KotlinType

    // Calculate bytes to allocate when creating a `RustBuffer`
    //
    // This must return at least as many bytes as the write() function will
    // write. It can return more bytes than needed, for example when writing
    // Strings we can't know the exact bytes needed until we the UTF-8
    // encoding, so we pessimistically allocate the largest size possible (3
    // bytes per codepoint).  Allocating extra bytes is not really a big deal
    // because the `RustBuffer` is short-lived.
    fun allocationSize(value: KotlinType): ULong

    // Write a Kotlin type to a `ByteBuffer`
    fun write(value: KotlinType, buf: ByteBuffer)

    // Lower a value into a `RustBuffer`
    //
    // This method lowers a value into a `RustBuffer` rather than the normal
    // FfiType.  It's used by the callback interface code.  Callback interface
    // returns are always serialized into a `RustBuffer` regardless of their
    // normal FFI type.
    fun lowerIntoRustBuffer(value: KotlinType): RustBuffer.ByValue {
        val rbuf = RustBuffer.alloc(allocationSize(value))
        try {
            val bbuf = rbuf.data!!.getByteBuffer(0, rbuf.capacity).also {
                it.order(ByteOrder.BIG_ENDIAN)
            }
            write(value, bbuf)
            rbuf.writeField("len", bbuf.position().toLong())
            return rbuf
        } catch (e: Throwable) {
            RustBuffer.free(rbuf)
            throw e
        }
    }

    // Lift a value from a `RustBuffer`.
    //
    // This here mostly because of the symmetry with `lowerIntoRustBuffer()`.
    // It's currently only used by the `FfiConverterRustBuffer` class below.
    fun liftFromRustBuffer(rbuf: RustBuffer.ByValue): KotlinType {
        val byteBuf = rbuf.asByteBuffer()!!
        try {
           val item = read(byteBuf)
           if (byteBuf.hasRemaining()) {
               throw RuntimeException("junk remaining in buffer after lifting, something is very wrong!!")
           }
           return item
        } finally {
            RustBuffer.free(rbuf)
        }
    }
}

/**
 * FfiConverter that uses `RustBuffer` as the FfiType
 *
 * @suppress
 */
public interface FfiConverterRustBuffer<KotlinType>: FfiConverter<KotlinType, RustBuffer.ByValue> {
    override fun lift(value: RustBuffer.ByValue) = liftFromRustBuffer(value)
    override fun lower(value: KotlinType) = lowerIntoRustBuffer(value)
}
// A handful of classes and functions to support the generated data structures.
// This would be a good candidate for isolating in its own ffi-support lib.

internal const val UNIFFI_CALL_SUCCESS = 0.toByte()
internal const val UNIFFI_CALL_ERROR = 1.toByte()
internal const val UNIFFI_CALL_UNEXPECTED_ERROR = 2.toByte()

@Structure.FieldOrder("code", "error_buf")
internal open class UniffiRustCallStatus : Structure() {
    @JvmField var code: Byte = 0
    @JvmField var error_buf: RustBuffer.ByValue = RustBuffer.ByValue()

    class ByValue: UniffiRustCallStatus(), Structure.ByValue

    fun isSuccess(): Boolean {
        return code == UNIFFI_CALL_SUCCESS
    }

    fun isError(): Boolean {
        return code == UNIFFI_CALL_ERROR
    }

    fun isPanic(): Boolean {
        return code == UNIFFI_CALL_UNEXPECTED_ERROR
    }

    companion object {
        fun create(code: Byte, errorBuf: RustBuffer.ByValue): UniffiRustCallStatus.ByValue {
            val callStatus = UniffiRustCallStatus.ByValue()
            callStatus.code = code
            callStatus.error_buf = errorBuf
            return callStatus
        }
    }
}

class InternalException(message: String) : kotlin.Exception(message)

/**
 * Each top-level error class has a companion object that can lift the error from the call status's rust buffer
 *
 * @suppress
 */
interface UniffiRustCallStatusErrorHandler<E> {
    fun lift(error_buf: RustBuffer.ByValue): E;
}

// Helpers for calling Rust
// In practice we usually need to be synchronized to call this safely, so it doesn't
// synchronize itself

// Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
private inline fun <U, E: kotlin.Exception> uniffiRustCallWithError(errorHandler: UniffiRustCallStatusErrorHandler<E>, callback: (UniffiRustCallStatus) -> U): U {
    var status = UniffiRustCallStatus()
    val return_value = callback(status)
    uniffiCheckCallStatus(errorHandler, status)
    return return_value
}

// Check UniffiRustCallStatus and throw an error if the call wasn't successful
private fun<E: kotlin.Exception> uniffiCheckCallStatus(errorHandler: UniffiRustCallStatusErrorHandler<E>, status: UniffiRustCallStatus) {
    if (status.isSuccess()) {
        return
    } else if (status.isError()) {
        throw errorHandler.lift(status.error_buf)
    } else if (status.isPanic()) {
        // when the rust code sees a panic, it tries to construct a rustbuffer
        // with the message.  but if that code panics, then it just sends back
        // an empty buffer.
        if (status.error_buf.len > 0) {
            throw InternalException(FfiConverterString.lift(status.error_buf))
        } else {
            throw InternalException("Rust panic")
        }
    } else {
        throw InternalException("Unknown rust call status: $status.code")
    }
}

/**
 * UniffiRustCallStatusErrorHandler implementation for times when we don't expect a CALL_ERROR
 *
 * @suppress
 */
object UniffiNullRustCallStatusErrorHandler: UniffiRustCallStatusErrorHandler<InternalException> {
    override fun lift(error_buf: RustBuffer.ByValue): InternalException {
        RustBuffer.free(error_buf)
        return InternalException("Unexpected CALL_ERROR")
    }
}

// Call a rust function that returns a plain value
private inline fun <U> uniffiRustCall(callback: (UniffiRustCallStatus) -> U): U {
    return uniffiRustCallWithError(UniffiNullRustCallStatusErrorHandler, callback)
}

internal inline fun<T> uniffiTraitInterfaceCall(
    callStatus: UniffiRustCallStatus,
    makeCall: () -> T,
    writeReturn: (T) -> Unit,
) {
    try {
        writeReturn(makeCall())
    } catch(e: kotlin.Exception) {
        callStatus.code = UNIFFI_CALL_UNEXPECTED_ERROR
        callStatus.error_buf = FfiConverterString.lower(e.toString())
    }
}

internal inline fun<T, reified E: Throwable> uniffiTraitInterfaceCallWithError(
    callStatus: UniffiRustCallStatus,
    makeCall: () -> T,
    writeReturn: (T) -> Unit,
    lowerError: (E) -> RustBuffer.ByValue
) {
    try {
        writeReturn(makeCall())
    } catch(e: kotlin.Exception) {
        if (e is E) {
            callStatus.code = UNIFFI_CALL_ERROR
            callStatus.error_buf = lowerError(e)
        } else {
            callStatus.code = UNIFFI_CALL_UNEXPECTED_ERROR
            callStatus.error_buf = FfiConverterString.lower(e.toString())
        }
    }
}
// Map handles to objects
//
// This is used pass an opaque 64-bit handle representing a foreign object to the Rust code.
internal class UniffiHandleMap<T: Any> {
    private val map = ConcurrentHashMap<Long, T>()
    private val counter = java.util.concurrent.atomic.AtomicLong(0)

    val size: Int
        get() = map.size

    // Insert a new object into the handle map and get a handle for it
    fun insert(obj: T): Long {
        val handle = counter.getAndAdd(1)
        map.put(handle, obj)
        return handle
    }

    // Get an object from the handle map
    fun get(handle: Long): T {
        return map.get(handle) ?: throw InternalException("UniffiHandleMap.get: Invalid handle")
    }

    // Remove an entry from the handlemap and get the Kotlin object back
    fun remove(handle: Long): T {
        return map.remove(handle) ?: throw InternalException("UniffiHandleMap: Invalid handle")
    }
}

// Contains loading, initialization code,
// and the FFI Function declarations in a com.sun.jna.Library.
@Synchronized
private fun findLibraryName(componentName: String): String {
    val libOverride = System.getProperty("uniffi.component.$componentName.libraryOverride")
    if (libOverride != null) {
        return libOverride
    }
    return "uniffi_yttrium"
}

private inline fun <reified Lib : Library> loadIndirect(
    componentName: String
): Lib {
    return Native.load<Lib>(findLibraryName(componentName), Lib::class.java)
}

// Define FFI callback types
internal interface UniffiRustFutureContinuationCallback : com.sun.jna.Callback {
    fun callback(`data`: Long,`pollResult`: Byte,)
}
internal interface UniffiForeignFutureFree : com.sun.jna.Callback {
    fun callback(`handle`: Long,)
}
internal interface UniffiCallbackInterfaceFree : com.sun.jna.Callback {
    fun callback(`handle`: Long,)
}
@Structure.FieldOrder("handle", "free")
internal open class UniffiForeignFuture(
    @JvmField internal var `handle`: Long = 0.toLong(),
    @JvmField internal var `free`: UniffiForeignFutureFree? = null,
) : Structure() {
    class UniffiByValue(
        `handle`: Long = 0.toLong(),
        `free`: UniffiForeignFutureFree? = null,
    ): UniffiForeignFuture(`handle`,`free`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFuture) {
        `handle` = other.`handle`
        `free` = other.`free`
    }

}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructU8(
    @JvmField internal var `returnValue`: Byte = 0.toByte(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Byte = 0.toByte(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructU8(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructU8) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteU8 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructU8.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructI8(
    @JvmField internal var `returnValue`: Byte = 0.toByte(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Byte = 0.toByte(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructI8(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructI8) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteI8 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructI8.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructU16(
    @JvmField internal var `returnValue`: Short = 0.toShort(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Short = 0.toShort(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructU16(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructU16) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteU16 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructU16.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructI16(
    @JvmField internal var `returnValue`: Short = 0.toShort(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Short = 0.toShort(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructI16(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructI16) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteI16 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructI16.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructU32(
    @JvmField internal var `returnValue`: Int = 0,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Int = 0,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructU32(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructU32) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteU32 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructU32.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructI32(
    @JvmField internal var `returnValue`: Int = 0,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Int = 0,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructI32(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructI32) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteI32 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructI32.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructU64(
    @JvmField internal var `returnValue`: Long = 0.toLong(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Long = 0.toLong(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructU64(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructU64) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteU64 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructU64.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructI64(
    @JvmField internal var `returnValue`: Long = 0.toLong(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Long = 0.toLong(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructI64(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructI64) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteI64 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructI64.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructF32(
    @JvmField internal var `returnValue`: Float = 0.0f,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Float = 0.0f,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructF32(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructF32) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteF32 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructF32.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructF64(
    @JvmField internal var `returnValue`: Double = 0.0,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Double = 0.0,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructF64(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructF64) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteF64 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructF64.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructPointer(
    @JvmField internal var `returnValue`: Pointer = Pointer.NULL,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Pointer = Pointer.NULL,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructPointer(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructPointer) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompletePointer : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructPointer.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructRustBuffer(
    @JvmField internal var `returnValue`: RustBuffer.ByValue = RustBuffer.ByValue(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: RustBuffer.ByValue = RustBuffer.ByValue(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructRustBuffer(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructRustBuffer) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteRustBuffer : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructRustBuffer.UniffiByValue,)
}
@Structure.FieldOrder("callStatus")
internal open class UniffiForeignFutureStructVoid(
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructVoid(`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructVoid) {
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteVoid : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructVoid.UniffiByValue,)
}
internal interface UniffiCallbackInterfaceLoggerMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`message`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceSignListenerMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`topic`: RustBuffer.ByValue,`sessionRequest`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceSignListenerMethod1 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`id`: Long,`topic`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceSignListenerMethod2 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`id`: Long,`topic`: RustBuffer.ByValue,`params`: Byte,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceSignListenerMethod3 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`id`: Long,`topic`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceSignListenerMethod4 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`id`: Long,`topic`: RustBuffer.ByValue,`namespaces`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceSignListenerMethod5 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`id`: Long,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceSignListenerMethod6 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`id`: Long,`topic`: RustBuffer.ByValue,`response`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceStorageFfiMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`session`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceStorageFfiMethod1 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`topic`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceStorageFfiMethod2 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`topic`: RustBuffer.ByValue,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceStorageFfiMethod3 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceStorageFfiMethod4 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceStorageFfiMethod5 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`topic`: RustBuffer.ByValue,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceStorageFfiMethod6 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`topic`: RustBuffer.ByValue,`rpcId`: Long,`symKey`: RustBuffer.ByValue,`selfKey`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceStorageFfiMethod7 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`topic`: RustBuffer.ByValue,`rpcId`: Long,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceStorageFfiMethod8 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`topic`: RustBuffer.ByValue,`symKey`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
@Structure.FieldOrder("log", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceLogger(
    @JvmField internal var `log`: UniffiCallbackInterfaceLoggerMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `log`: UniffiCallbackInterfaceLoggerMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceLogger(`log`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceLogger) {
        `log` = other.`log`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("onSessionRequest", "onSessionDisconnect", "onSessionEvent", "onSessionExtend", "onSessionUpdate", "onSessionConnect", "onSessionRequestResponse", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceSignListener(
    @JvmField internal var `onSessionRequest`: UniffiCallbackInterfaceSignListenerMethod0? = null,
    @JvmField internal var `onSessionDisconnect`: UniffiCallbackInterfaceSignListenerMethod1? = null,
    @JvmField internal var `onSessionEvent`: UniffiCallbackInterfaceSignListenerMethod2? = null,
    @JvmField internal var `onSessionExtend`: UniffiCallbackInterfaceSignListenerMethod3? = null,
    @JvmField internal var `onSessionUpdate`: UniffiCallbackInterfaceSignListenerMethod4? = null,
    @JvmField internal var `onSessionConnect`: UniffiCallbackInterfaceSignListenerMethod5? = null,
    @JvmField internal var `onSessionRequestResponse`: UniffiCallbackInterfaceSignListenerMethod6? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `onSessionRequest`: UniffiCallbackInterfaceSignListenerMethod0? = null,
        `onSessionDisconnect`: UniffiCallbackInterfaceSignListenerMethod1? = null,
        `onSessionEvent`: UniffiCallbackInterfaceSignListenerMethod2? = null,
        `onSessionExtend`: UniffiCallbackInterfaceSignListenerMethod3? = null,
        `onSessionUpdate`: UniffiCallbackInterfaceSignListenerMethod4? = null,
        `onSessionConnect`: UniffiCallbackInterfaceSignListenerMethod5? = null,
        `onSessionRequestResponse`: UniffiCallbackInterfaceSignListenerMethod6? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceSignListener(`onSessionRequest`,`onSessionDisconnect`,`onSessionEvent`,`onSessionExtend`,`onSessionUpdate`,`onSessionConnect`,`onSessionRequestResponse`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceSignListener) {
        `onSessionRequest` = other.`onSessionRequest`
        `onSessionDisconnect` = other.`onSessionDisconnect`
        `onSessionEvent` = other.`onSessionEvent`
        `onSessionExtend` = other.`onSessionExtend`
        `onSessionUpdate` = other.`onSessionUpdate`
        `onSessionConnect` = other.`onSessionConnect`
        `onSessionRequestResponse` = other.`onSessionRequestResponse`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("addSession", "deleteSession", "getSession", "getAllSessions", "getAllTopics", "getDecryptionKeyForTopic", "savePairing", "getPairing", "savePartialSession", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceStorageFfi(
    @JvmField internal var `addSession`: UniffiCallbackInterfaceStorageFfiMethod0? = null,
    @JvmField internal var `deleteSession`: UniffiCallbackInterfaceStorageFfiMethod1? = null,
    @JvmField internal var `getSession`: UniffiCallbackInterfaceStorageFfiMethod2? = null,
    @JvmField internal var `getAllSessions`: UniffiCallbackInterfaceStorageFfiMethod3? = null,
    @JvmField internal var `getAllTopics`: UniffiCallbackInterfaceStorageFfiMethod4? = null,
    @JvmField internal var `getDecryptionKeyForTopic`: UniffiCallbackInterfaceStorageFfiMethod5? = null,
    @JvmField internal var `savePairing`: UniffiCallbackInterfaceStorageFfiMethod6? = null,
    @JvmField internal var `getPairing`: UniffiCallbackInterfaceStorageFfiMethod7? = null,
    @JvmField internal var `savePartialSession`: UniffiCallbackInterfaceStorageFfiMethod8? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `addSession`: UniffiCallbackInterfaceStorageFfiMethod0? = null,
        `deleteSession`: UniffiCallbackInterfaceStorageFfiMethod1? = null,
        `getSession`: UniffiCallbackInterfaceStorageFfiMethod2? = null,
        `getAllSessions`: UniffiCallbackInterfaceStorageFfiMethod3? = null,
        `getAllTopics`: UniffiCallbackInterfaceStorageFfiMethod4? = null,
        `getDecryptionKeyForTopic`: UniffiCallbackInterfaceStorageFfiMethod5? = null,
        `savePairing`: UniffiCallbackInterfaceStorageFfiMethod6? = null,
        `getPairing`: UniffiCallbackInterfaceStorageFfiMethod7? = null,
        `savePartialSession`: UniffiCallbackInterfaceStorageFfiMethod8? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceStorageFfi(`addSession`,`deleteSession`,`getSession`,`getAllSessions`,`getAllTopics`,`getDecryptionKeyForTopic`,`savePairing`,`getPairing`,`savePartialSession`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceStorageFfi) {
        `addSession` = other.`addSession`
        `deleteSession` = other.`deleteSession`
        `getSession` = other.`getSession`
        `getAllSessions` = other.`getAllSessions`
        `getAllTopics` = other.`getAllTopics`
        `getDecryptionKeyForTopic` = other.`getDecryptionKeyForTopic`
        `savePairing` = other.`savePairing`
        `getPairing` = other.`getPairing`
        `savePartialSession` = other.`savePartialSession`
        `uniffiFree` = other.`uniffiFree`
    }

}





















































































































































































































































// For large crates we prevent `MethodTooLargeException` (see #2340)
// N.B. the name of the extension is very misleading, since it is 
// rather `InterfaceTooLargeException`, caused by too many methods 
// in the interface for large crates.
//
// By splitting the otherwise huge interface into two parts
// * UniffiLib 
// * IntegrityCheckingUniffiLib (this)
// we allow for ~2x as many methods in the UniffiLib interface.
// 
// The `ffi_uniffi_contract_version` method and all checksum methods are put 
// into `IntegrityCheckingUniffiLib` and these methods are called only once,
// when the library is loaded.
internal interface IntegrityCheckingUniffiLib : Library {
    // Integrity check functions only
    fun uniffi_yttrium_checksum_func_error_data_ffi_from_json(
): Short
fun uniffi_yttrium_checksum_func_error_data_ffi_to_json(
): Short
fun uniffi_yttrium_checksum_func_funding_metadata_to_amount(
): Short
fun uniffi_yttrium_checksum_func_funding_metadata_to_bridging_fee_amount(
): Short
fun uniffi_yttrium_checksum_func_metadata_from_json(
): Short
fun uniffi_yttrium_checksum_func_metadata_to_json(
): Short
fun uniffi_yttrium_checksum_func_proposal_namespace_from_json(
): Short
fun uniffi_yttrium_checksum_func_proposal_namespace_to_json(
): Short
fun uniffi_yttrium_checksum_func_redirect_from_json(
): Short
fun uniffi_yttrium_checksum_func_redirect_to_json(
): Short
fun uniffi_yttrium_checksum_func_register_logger(
): Short
fun uniffi_yttrium_checksum_func_relay_from_json(
): Short
fun uniffi_yttrium_checksum_func_relay_to_json(
): Short
fun uniffi_yttrium_checksum_func_session_ffi_from_json(
): Short
fun uniffi_yttrium_checksum_func_session_ffi_to_json(
): Short
fun uniffi_yttrium_checksum_func_session_proposal_ffi_from_json(
): Short
fun uniffi_yttrium_checksum_func_session_proposal_ffi_to_json(
): Short
fun uniffi_yttrium_checksum_func_session_request_ffi_from_json(
): Short
fun uniffi_yttrium_checksum_func_session_request_ffi_to_json(
): Short
fun uniffi_yttrium_checksum_func_session_request_json_rpc_error_response_ffi_from_json(
): Short
fun uniffi_yttrium_checksum_func_session_request_json_rpc_error_response_ffi_to_json(
): Short
fun uniffi_yttrium_checksum_func_session_request_json_rpc_ffi_from_json(
): Short
fun uniffi_yttrium_checksum_func_session_request_json_rpc_ffi_to_json(
): Short
fun uniffi_yttrium_checksum_func_session_request_json_rpc_result_response_ffi_from_json(
): Short
fun uniffi_yttrium_checksum_func_session_request_json_rpc_result_response_ffi_to_json(
): Short
fun uniffi_yttrium_checksum_func_session_request_request_ffi_to_json(
): Short
fun uniffi_yttrium_checksum_func_session_request_request_from_json(
): Short
fun uniffi_yttrium_checksum_func_settle_namespace_from_json(
): Short
fun uniffi_yttrium_checksum_func_settle_namespace_to_json(
): Short
fun uniffi_yttrium_checksum_func_solana_derive_keypair_from_mnemonic(
): Short
fun uniffi_yttrium_checksum_func_solana_generate_keypair(
): Short
fun uniffi_yttrium_checksum_func_solana_phantom_derivation_path_with_account(
): Short
fun uniffi_yttrium_checksum_func_solana_pubkey_for_keypair(
): Short
fun uniffi_yttrium_checksum_func_solana_sign_prehash(
): Short
fun uniffi_yttrium_checksum_func_stacks_generate_wallet(
): Short
fun uniffi_yttrium_checksum_func_stacks_get_address(
): Short
fun uniffi_yttrium_checksum_func_stacks_sign_message(
): Short
fun uniffi_yttrium_checksum_func_sui_derive_keypair_from_mnemonic(
): Short
fun uniffi_yttrium_checksum_func_sui_generate_keypair(
): Short
fun uniffi_yttrium_checksum_func_sui_get_address(
): Short
fun uniffi_yttrium_checksum_func_sui_get_public_key(
): Short
fun uniffi_yttrium_checksum_func_sui_personal_sign(
): Short
fun uniffi_yttrium_checksum_method_erc6492client_verify_signature(
): Short
fun uniffi_yttrium_checksum_method_logger_log(
): Short
fun uniffi_yttrium_checksum_method_signclient_approve(
): Short
fun uniffi_yttrium_checksum_method_signclient_connect(
): Short
fun uniffi_yttrium_checksum_method_signclient_disconnect(
): Short
fun uniffi_yttrium_checksum_method_signclient_extend(
): Short
fun uniffi_yttrium_checksum_method_signclient_generate_key(
): Short
fun uniffi_yttrium_checksum_method_signclient_online(
): Short
fun uniffi_yttrium_checksum_method_signclient_pair(
): Short
fun uniffi_yttrium_checksum_method_signclient_register_sign_listener(
): Short
fun uniffi_yttrium_checksum_method_signclient_reject(
): Short
fun uniffi_yttrium_checksum_method_signclient_request(
): Short
fun uniffi_yttrium_checksum_method_signclient_respond(
): Short
fun uniffi_yttrium_checksum_method_signclient_start(
): Short
fun uniffi_yttrium_checksum_method_signclient_update(
): Short
fun uniffi_yttrium_checksum_method_signlistener_on_session_request(
): Short
fun uniffi_yttrium_checksum_method_signlistener_on_session_disconnect(
): Short
fun uniffi_yttrium_checksum_method_signlistener_on_session_event(
): Short
fun uniffi_yttrium_checksum_method_signlistener_on_session_extend(
): Short
fun uniffi_yttrium_checksum_method_signlistener_on_session_update(
): Short
fun uniffi_yttrium_checksum_method_signlistener_on_session_connect(
): Short
fun uniffi_yttrium_checksum_method_signlistener_on_session_request_response(
): Short
fun uniffi_yttrium_checksum_method_stacksclient_get_account(
): Short
fun uniffi_yttrium_checksum_method_stacksclient_transfer_fees(
): Short
fun uniffi_yttrium_checksum_method_stacksclient_transfer_stx(
): Short
fun uniffi_yttrium_checksum_method_storageffi_add_session(
): Short
fun uniffi_yttrium_checksum_method_storageffi_delete_session(
): Short
fun uniffi_yttrium_checksum_method_storageffi_get_session(
): Short
fun uniffi_yttrium_checksum_method_storageffi_get_all_sessions(
): Short
fun uniffi_yttrium_checksum_method_storageffi_get_all_topics(
): Short
fun uniffi_yttrium_checksum_method_storageffi_get_decryption_key_for_topic(
): Short
fun uniffi_yttrium_checksum_method_storageffi_save_pairing(
): Short
fun uniffi_yttrium_checksum_method_storageffi_get_pairing(
): Short
fun uniffi_yttrium_checksum_method_storageffi_save_partial_session(
): Short
fun uniffi_yttrium_checksum_method_suiclient_get_all_balances(
): Short
fun uniffi_yttrium_checksum_method_suiclient_sign_and_execute_transaction(
): Short
fun uniffi_yttrium_checksum_method_suiclient_sign_transaction(
): Short
fun uniffi_yttrium_checksum_constructor_erc6492client_new(
): Short
fun uniffi_yttrium_checksum_constructor_signclient_new(
): Short
fun uniffi_yttrium_checksum_constructor_stacksclient_new(
): Short
fun uniffi_yttrium_checksum_constructor_stacksclient_with_blockchain_api_url(
): Short
fun uniffi_yttrium_checksum_constructor_suiclient_new(
): Short
fun uniffi_yttrium_checksum_constructor_suiclient_with_blockchain_api_url(
): Short
fun ffi_yttrium_uniffi_contract_version(
): Int

}

// A JNA Library to expose the extern-C FFI definitions.
// This is an implementation detail which will be called internally by the public API.
internal interface UniffiLib : Library {
    companion object {
        internal val INSTANCE: UniffiLib by lazy {
            val componentName = "yttrium"
            // For large crates we prevent `MethodTooLargeException` (see #2340)
            // N.B. the name of the extension is very misleading, since it is 
            // rather `InterfaceTooLargeException`, caused by too many methods 
            // in the interface for large crates.
            //
            // By splitting the otherwise huge interface into two parts
            // * UniffiLib (this)
            // * IntegrityCheckingUniffiLib
            // And all checksum methods are put into `IntegrityCheckingUniffiLib`
            // we allow for ~2x as many methods in the UniffiLib interface.
            // 
            // Thus we first load the library with `loadIndirect` as `IntegrityCheckingUniffiLib`
            // so that we can (optionally!) call `uniffiCheckApiChecksums`...
            loadIndirect<IntegrityCheckingUniffiLib>(componentName)
                .also { lib: IntegrityCheckingUniffiLib ->
                    uniffiCheckContractApiVersion(lib)
                    uniffiCheckApiChecksums(lib)
                }
            // ... and then we load the library as `UniffiLib`
            // N.B. we cannot use `loadIndirect` once and then try to cast it to `UniffiLib`
            // => results in `java.lang.ClassCastException: com.sun.proxy.$Proxy cannot be cast to ...`
            // error. So we must call `loadIndirect` twice. For crates large enough
            // to trigger this issue, the performance impact is negligible, running on
            // a macOS M1 machine the `loadIndirect` call takes ~50ms.
            val lib = loadIndirect<UniffiLib>(componentName)
            // No need to check the contract version and checksums, since 
            // we already did that with `IntegrityCheckingUniffiLib` above.
            uniffiCallbackInterfaceLogger.register(lib)
            uniffiCallbackInterfaceSignListener.register(lib)
            uniffiCallbackInterfaceStorageFfi.register(lib)
            // Loading of library with integrity check done.
            lib
        }
        
        // The Cleaner for the whole library
        internal val CLEANER: UniffiCleaner by lazy {
            UniffiCleaner.create()
        }
    }

    // FFI functions
    fun uniffi_yttrium_fn_clone_erc6492client(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_yttrium_fn_free_erc6492client(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_yttrium_fn_constructor_erc6492client_new(`rpcUrl`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_yttrium_fn_method_erc6492client_verify_signature(`ptr`: Pointer,`signature`: RustBuffer.ByValue,`address`: RustBuffer.ByValue,`messageHash`: RustBuffer.ByValue,
): Long
fun uniffi_yttrium_fn_clone_logger(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_yttrium_fn_free_logger(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_yttrium_fn_init_callback_vtable_logger(`vtable`: UniffiVTableCallbackInterfaceLogger,
): Unit
fun uniffi_yttrium_fn_method_logger_log(`ptr`: Pointer,`message`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_yttrium_fn_clone_signclient(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_yttrium_fn_free_signclient(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_yttrium_fn_constructor_signclient_new(`projectId`: RustBuffer.ByValue,`key`: RustBuffer.ByValue,`sessionStore`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_yttrium_fn_method_signclient_approve(`ptr`: Pointer,`proposal`: RustBuffer.ByValue,`approvedNamespaces`: RustBuffer.ByValue,`selfMetadata`: RustBuffer.ByValue,
): Long
fun uniffi_yttrium_fn_method_signclient_connect(`ptr`: Pointer,`params`: RustBuffer.ByValue,`selfMetadata`: RustBuffer.ByValue,
): Long
fun uniffi_yttrium_fn_method_signclient_disconnect(`ptr`: Pointer,`topic`: RustBuffer.ByValue,
): Long
fun uniffi_yttrium_fn_method_signclient_extend(`ptr`: Pointer,`topic`: RustBuffer.ByValue,
): Long
fun uniffi_yttrium_fn_method_signclient_generate_key(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_yttrium_fn_method_signclient_online(`ptr`: Pointer,
): Long
fun uniffi_yttrium_fn_method_signclient_pair(`ptr`: Pointer,`uri`: RustBuffer.ByValue,
): Long
fun uniffi_yttrium_fn_method_signclient_register_sign_listener(`ptr`: Pointer,`listener`: Pointer,
): Long
fun uniffi_yttrium_fn_method_signclient_reject(`ptr`: Pointer,`proposal`: RustBuffer.ByValue,`reason`: RustBuffer.ByValue,
): Long
fun uniffi_yttrium_fn_method_signclient_request(`ptr`: Pointer,`topic`: RustBuffer.ByValue,`sessionRequest`: RustBuffer.ByValue,
): Long
fun uniffi_yttrium_fn_method_signclient_respond(`ptr`: Pointer,`topic`: RustBuffer.ByValue,`response`: RustBuffer.ByValue,
): Long
fun uniffi_yttrium_fn_method_signclient_start(`ptr`: Pointer,
): Long
fun uniffi_yttrium_fn_method_signclient_update(`ptr`: Pointer,`topic`: RustBuffer.ByValue,`namespaces`: RustBuffer.ByValue,
): Long
fun uniffi_yttrium_fn_clone_signlistener(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_yttrium_fn_free_signlistener(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_yttrium_fn_init_callback_vtable_signlistener(`vtable`: UniffiVTableCallbackInterfaceSignListener,
): Unit
fun uniffi_yttrium_fn_method_signlistener_on_session_request(`ptr`: Pointer,`topic`: RustBuffer.ByValue,`sessionRequest`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_yttrium_fn_method_signlistener_on_session_disconnect(`ptr`: Pointer,`id`: Long,`topic`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_yttrium_fn_method_signlistener_on_session_event(`ptr`: Pointer,`id`: Long,`topic`: RustBuffer.ByValue,`params`: Byte,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_yttrium_fn_method_signlistener_on_session_extend(`ptr`: Pointer,`id`: Long,`topic`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_yttrium_fn_method_signlistener_on_session_update(`ptr`: Pointer,`id`: Long,`topic`: RustBuffer.ByValue,`namespaces`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_yttrium_fn_method_signlistener_on_session_connect(`ptr`: Pointer,`id`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_yttrium_fn_method_signlistener_on_session_request_response(`ptr`: Pointer,`id`: Long,`topic`: RustBuffer.ByValue,`response`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_yttrium_fn_clone_stacksclient(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_yttrium_fn_free_stacksclient(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_yttrium_fn_constructor_stacksclient_new(`projectId`: RustBuffer.ByValue,`pulseMetadata`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_yttrium_fn_constructor_stacksclient_with_blockchain_api_url(`projectId`: RustBuffer.ByValue,`pulseMetadata`: RustBuffer.ByValue,`blockchainApiBaseUrl`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_yttrium_fn_method_stacksclient_get_account(`ptr`: Pointer,`network`: RustBuffer.ByValue,`principal`: RustBuffer.ByValue,
): Long
fun uniffi_yttrium_fn_method_stacksclient_transfer_fees(`ptr`: Pointer,`network`: RustBuffer.ByValue,
): Long
fun uniffi_yttrium_fn_method_stacksclient_transfer_stx(`ptr`: Pointer,`wallet`: RustBuffer.ByValue,`network`: RustBuffer.ByValue,`request`: RustBuffer.ByValue,
): Long
fun uniffi_yttrium_fn_clone_storageffi(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_yttrium_fn_free_storageffi(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_yttrium_fn_init_callback_vtable_storageffi(`vtable`: UniffiVTableCallbackInterfaceStorageFfi,
): Unit
fun uniffi_yttrium_fn_method_storageffi_add_session(`ptr`: Pointer,`session`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_yttrium_fn_method_storageffi_delete_session(`ptr`: Pointer,`topic`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_yttrium_fn_method_storageffi_get_session(`ptr`: Pointer,`topic`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_yttrium_fn_method_storageffi_get_all_sessions(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_yttrium_fn_method_storageffi_get_all_topics(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_yttrium_fn_method_storageffi_get_decryption_key_for_topic(`ptr`: Pointer,`topic`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_yttrium_fn_method_storageffi_save_pairing(`ptr`: Pointer,`topic`: RustBuffer.ByValue,`rpcId`: Long,`symKey`: RustBuffer.ByValue,`selfKey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_yttrium_fn_method_storageffi_get_pairing(`ptr`: Pointer,`topic`: RustBuffer.ByValue,`rpcId`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_yttrium_fn_method_storageffi_save_partial_session(`ptr`: Pointer,`topic`: RustBuffer.ByValue,`symKey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_yttrium_fn_clone_suiclient(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_yttrium_fn_free_suiclient(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_yttrium_fn_constructor_suiclient_new(`projectId`: RustBuffer.ByValue,`pulseMetadata`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_yttrium_fn_constructor_suiclient_with_blockchain_api_url(`projectId`: RustBuffer.ByValue,`pulseMetadata`: RustBuffer.ByValue,`blockchainApiBaseUrl`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_yttrium_fn_method_suiclient_get_all_balances(`ptr`: Pointer,`chainId`: RustBuffer.ByValue,`address`: RustBuffer.ByValue,
): Long
fun uniffi_yttrium_fn_method_suiclient_sign_and_execute_transaction(`ptr`: Pointer,`chainId`: RustBuffer.ByValue,`keypair`: RustBuffer.ByValue,`txData`: RustBuffer.ByValue,
): Long
fun uniffi_yttrium_fn_method_suiclient_sign_transaction(`ptr`: Pointer,`chainId`: RustBuffer.ByValue,`keypair`: RustBuffer.ByValue,`txData`: RustBuffer.ByValue,
): Long
fun uniffi_yttrium_fn_func_error_data_ffi_from_json(`json`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_yttrium_fn_func_error_data_ffi_to_json(`object`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_yttrium_fn_func_funding_metadata_to_amount(`value`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_yttrium_fn_func_funding_metadata_to_bridging_fee_amount(`value`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_yttrium_fn_func_metadata_from_json(`json`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_yttrium_fn_func_metadata_to_json(`object`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_yttrium_fn_func_proposal_namespace_from_json(`json`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_yttrium_fn_func_proposal_namespace_to_json(`object`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_yttrium_fn_func_redirect_from_json(`json`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_yttrium_fn_func_redirect_to_json(`object`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_yttrium_fn_func_register_logger(`logger`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_yttrium_fn_func_relay_from_json(`json`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_yttrium_fn_func_relay_to_json(`object`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_yttrium_fn_func_session_ffi_from_json(`json`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_yttrium_fn_func_session_ffi_to_json(`object`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_yttrium_fn_func_session_proposal_ffi_from_json(`json`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_yttrium_fn_func_session_proposal_ffi_to_json(`object`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_yttrium_fn_func_session_request_ffi_from_json(`json`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_yttrium_fn_func_session_request_ffi_to_json(`object`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_yttrium_fn_func_session_request_json_rpc_error_response_ffi_from_json(`json`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_yttrium_fn_func_session_request_json_rpc_error_response_ffi_to_json(`object`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_yttrium_fn_func_session_request_json_rpc_ffi_from_json(`json`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_yttrium_fn_func_session_request_json_rpc_ffi_to_json(`object`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_yttrium_fn_func_session_request_json_rpc_result_response_ffi_from_json(`json`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_yttrium_fn_func_session_request_json_rpc_result_response_ffi_to_json(`object`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_yttrium_fn_func_session_request_request_ffi_to_json(`object`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_yttrium_fn_func_session_request_request_from_json(`json`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_yttrium_fn_func_settle_namespace_from_json(`json`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_yttrium_fn_func_settle_namespace_to_json(`object`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_yttrium_fn_func_solana_derive_keypair_from_mnemonic(`mnemonic`: RustBuffer.ByValue,`derivationPath`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_yttrium_fn_func_solana_generate_keypair(uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_yttrium_fn_func_solana_phantom_derivation_path_with_account(`account`: Int,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_yttrium_fn_func_solana_pubkey_for_keypair(`keypair`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_yttrium_fn_func_solana_sign_prehash(`keypair`: RustBuffer.ByValue,`message`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_yttrium_fn_func_stacks_generate_wallet(uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_yttrium_fn_func_stacks_get_address(`wallet`: RustBuffer.ByValue,`version`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_yttrium_fn_func_stacks_sign_message(`wallet`: RustBuffer.ByValue,`message`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_yttrium_fn_func_sui_derive_keypair_from_mnemonic(`mnemonic`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_yttrium_fn_func_sui_generate_keypair(uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_yttrium_fn_func_sui_get_address(`publicKey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_yttrium_fn_func_sui_get_public_key(`keypair`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_yttrium_fn_func_sui_personal_sign(`keypair`: RustBuffer.ByValue,`message`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun ffi_yttrium_rustbuffer_alloc(`size`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun ffi_yttrium_rustbuffer_from_bytes(`bytes`: ForeignBytes.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun ffi_yttrium_rustbuffer_free(`buf`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun ffi_yttrium_rustbuffer_reserve(`buf`: RustBuffer.ByValue,`additional`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun ffi_yttrium_rust_future_poll_u8(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_yttrium_rust_future_cancel_u8(`handle`: Long,
): Unit
fun ffi_yttrium_rust_future_free_u8(`handle`: Long,
): Unit
fun ffi_yttrium_rust_future_complete_u8(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun ffi_yttrium_rust_future_poll_i8(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_yttrium_rust_future_cancel_i8(`handle`: Long,
): Unit
fun ffi_yttrium_rust_future_free_i8(`handle`: Long,
): Unit
fun ffi_yttrium_rust_future_complete_i8(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun ffi_yttrium_rust_future_poll_u16(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_yttrium_rust_future_cancel_u16(`handle`: Long,
): Unit
fun ffi_yttrium_rust_future_free_u16(`handle`: Long,
): Unit
fun ffi_yttrium_rust_future_complete_u16(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Short
fun ffi_yttrium_rust_future_poll_i16(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_yttrium_rust_future_cancel_i16(`handle`: Long,
): Unit
fun ffi_yttrium_rust_future_free_i16(`handle`: Long,
): Unit
fun ffi_yttrium_rust_future_complete_i16(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Short
fun ffi_yttrium_rust_future_poll_u32(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_yttrium_rust_future_cancel_u32(`handle`: Long,
): Unit
fun ffi_yttrium_rust_future_free_u32(`handle`: Long,
): Unit
fun ffi_yttrium_rust_future_complete_u32(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Int
fun ffi_yttrium_rust_future_poll_i32(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_yttrium_rust_future_cancel_i32(`handle`: Long,
): Unit
fun ffi_yttrium_rust_future_free_i32(`handle`: Long,
): Unit
fun ffi_yttrium_rust_future_complete_i32(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Int
fun ffi_yttrium_rust_future_poll_u64(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_yttrium_rust_future_cancel_u64(`handle`: Long,
): Unit
fun ffi_yttrium_rust_future_free_u64(`handle`: Long,
): Unit
fun ffi_yttrium_rust_future_complete_u64(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun ffi_yttrium_rust_future_poll_i64(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_yttrium_rust_future_cancel_i64(`handle`: Long,
): Unit
fun ffi_yttrium_rust_future_free_i64(`handle`: Long,
): Unit
fun ffi_yttrium_rust_future_complete_i64(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun ffi_yttrium_rust_future_poll_f32(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_yttrium_rust_future_cancel_f32(`handle`: Long,
): Unit
fun ffi_yttrium_rust_future_free_f32(`handle`: Long,
): Unit
fun ffi_yttrium_rust_future_complete_f32(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Float
fun ffi_yttrium_rust_future_poll_f64(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_yttrium_rust_future_cancel_f64(`handle`: Long,
): Unit
fun ffi_yttrium_rust_future_free_f64(`handle`: Long,
): Unit
fun ffi_yttrium_rust_future_complete_f64(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Double
fun ffi_yttrium_rust_future_poll_pointer(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_yttrium_rust_future_cancel_pointer(`handle`: Long,
): Unit
fun ffi_yttrium_rust_future_free_pointer(`handle`: Long,
): Unit
fun ffi_yttrium_rust_future_complete_pointer(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun ffi_yttrium_rust_future_poll_rust_buffer(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_yttrium_rust_future_cancel_rust_buffer(`handle`: Long,
): Unit
fun ffi_yttrium_rust_future_free_rust_buffer(`handle`: Long,
): Unit
fun ffi_yttrium_rust_future_complete_rust_buffer(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun ffi_yttrium_rust_future_poll_void(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_yttrium_rust_future_cancel_void(`handle`: Long,
): Unit
fun ffi_yttrium_rust_future_free_void(`handle`: Long,
): Unit
fun ffi_yttrium_rust_future_complete_void(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit

}

private fun uniffiCheckContractApiVersion(lib: IntegrityCheckingUniffiLib) {
    // Get the bindings contract version from our ComponentInterface
    val bindings_contract_version = 29
    // Get the scaffolding contract version by calling the into the dylib
    val scaffolding_contract_version = lib.ffi_yttrium_uniffi_contract_version()
    if (bindings_contract_version != scaffolding_contract_version) {
        throw RuntimeException("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    }
}
@Suppress("UNUSED_PARAMETER")
private fun uniffiCheckApiChecksums(lib: IntegrityCheckingUniffiLib) {
    if (lib.uniffi_yttrium_checksum_func_error_data_ffi_from_json() != 45212.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_func_error_data_ffi_to_json() != 30275.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_func_funding_metadata_to_amount() != 52092.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_func_funding_metadata_to_bridging_fee_amount() != 38273.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_func_metadata_from_json() != 29441.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_func_metadata_to_json() != 41553.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_func_proposal_namespace_from_json() != 339.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_func_proposal_namespace_to_json() != 60026.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_func_redirect_from_json() != 21514.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_func_redirect_to_json() != 31534.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_func_register_logger() != 53062.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_func_relay_from_json() != 49040.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_func_relay_to_json() != 35189.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_func_session_ffi_from_json() != 41917.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_func_session_ffi_to_json() != 30234.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_func_session_proposal_ffi_from_json() != 30864.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_func_session_proposal_ffi_to_json() != 43109.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_func_session_request_ffi_from_json() != 33789.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_func_session_request_ffi_to_json() != 17435.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_func_session_request_json_rpc_error_response_ffi_from_json() != 6802.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_func_session_request_json_rpc_error_response_ffi_to_json() != 19261.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_func_session_request_json_rpc_ffi_from_json() != 60984.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_func_session_request_json_rpc_ffi_to_json() != 10372.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_func_session_request_json_rpc_result_response_ffi_from_json() != 57212.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_func_session_request_json_rpc_result_response_ffi_to_json() != 47087.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_func_session_request_request_ffi_to_json() != 34926.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_func_session_request_request_from_json() != 11151.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_func_settle_namespace_from_json() != 852.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_func_settle_namespace_to_json() != 48776.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_func_solana_derive_keypair_from_mnemonic() != 769.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_func_solana_generate_keypair() != 30305.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_func_solana_phantom_derivation_path_with_account() != 15080.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_func_solana_pubkey_for_keypair() != 27700.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_func_solana_sign_prehash() != 19355.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_func_stacks_generate_wallet() != 8623.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_func_stacks_get_address() != 14379.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_func_stacks_sign_message() != 52767.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_func_sui_derive_keypair_from_mnemonic() != 51451.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_func_sui_generate_keypair() != 3308.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_func_sui_get_address() != 64923.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_func_sui_get_public_key() != 65033.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_func_sui_personal_sign() != 21640.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_method_erc6492client_verify_signature() != 43990.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_method_logger_log() != 540.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_method_signclient_approve() != 36526.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_method_signclient_connect() != 9786.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_method_signclient_disconnect() != 50012.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_method_signclient_extend() != 44693.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_method_signclient_generate_key() != 3304.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_method_signclient_online() != 2068.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_method_signclient_pair() != 59076.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_method_signclient_register_sign_listener() != 37537.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_method_signclient_reject() != 23118.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_method_signclient_request() != 21112.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_method_signclient_respond() != 17745.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_method_signclient_start() != 35500.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_method_signclient_update() != 8371.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_method_signlistener_on_session_request() != 45061.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_method_signlistener_on_session_disconnect() != 39985.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_method_signlistener_on_session_event() != 17798.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_method_signlistener_on_session_extend() != 55166.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_method_signlistener_on_session_update() != 23427.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_method_signlistener_on_session_connect() != 15582.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_method_signlistener_on_session_request_response() != 32789.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_method_stacksclient_get_account() != 47469.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_method_stacksclient_transfer_fees() != 35491.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_method_stacksclient_transfer_stx() != 55030.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_method_storageffi_add_session() != 6835.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_method_storageffi_delete_session() != 59547.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_method_storageffi_get_session() != 17235.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_method_storageffi_get_all_sessions() != 64457.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_method_storageffi_get_all_topics() != 46741.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_method_storageffi_get_decryption_key_for_topic() != 11806.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_method_storageffi_save_pairing() != 54269.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_method_storageffi_get_pairing() != 14525.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_method_storageffi_save_partial_session() != 37310.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_method_suiclient_get_all_balances() != 49534.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_method_suiclient_sign_and_execute_transaction() != 3492.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_method_suiclient_sign_transaction() != 14754.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_constructor_erc6492client_new() != 33633.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_constructor_signclient_new() != 10454.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_constructor_stacksclient_new() != 14610.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_constructor_stacksclient_with_blockchain_api_url() != 37649.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_constructor_suiclient_new() != 11380.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_yttrium_checksum_constructor_suiclient_with_blockchain_api_url() != 31125.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

/**
 * @suppress
 */
public fun uniffiEnsureInitialized() {
    UniffiLib.INSTANCE
}

// Async support
// Async return type handlers

internal const val UNIFFI_RUST_FUTURE_POLL_READY = 0.toByte()
internal const val UNIFFI_RUST_FUTURE_POLL_MAYBE_READY = 1.toByte()

internal val uniffiContinuationHandleMap = UniffiHandleMap<CancellableContinuation<Byte>>()

// FFI type for Rust future continuations
internal object uniffiRustFutureContinuationCallbackImpl: UniffiRustFutureContinuationCallback {
    override fun callback(data: Long, pollResult: Byte) {
        uniffiContinuationHandleMap.remove(data).resume(pollResult)
    }
}

internal suspend fun<T, F, E: kotlin.Exception> uniffiRustCallAsync(
    rustFuture: Long,
    pollFunc: (Long, UniffiRustFutureContinuationCallback, Long) -> Unit,
    completeFunc: (Long, UniffiRustCallStatus) -> F,
    freeFunc: (Long) -> Unit,
    liftFunc: (F) -> T,
    errorHandler: UniffiRustCallStatusErrorHandler<E>
): T {
    try {
        do {
            val pollResult = suspendCancellableCoroutine<Byte> { continuation ->
                pollFunc(
                    rustFuture,
                    uniffiRustFutureContinuationCallbackImpl,
                    uniffiContinuationHandleMap.insert(continuation)
                )
            }
        } while (pollResult != UNIFFI_RUST_FUTURE_POLL_READY);

        return liftFunc(
            uniffiRustCallWithError(errorHandler, { status -> completeFunc(rustFuture, status) })
        )
    } finally {
        freeFunc(rustFuture)
    }
}

// Public interface members begin here.


// Interface implemented by anything that can contain an object reference.
//
// Such types expose a `destroy()` method that must be called to cleanly
// dispose of the contained objects. Failure to call this method may result
// in memory leaks.
//
// The easiest way to ensure this method is called is to use the `.use`
// helper method to execute a block and destroy the object at the end.
interface Disposable {
    fun destroy()
    companion object {
        fun destroy(vararg args: Any?) {
            for (arg in args) {
                when (arg) {
                    is Disposable -> arg.destroy()
                    is ArrayList<*> -> {
                        for (idx in arg.indices) {
                            val element = arg[idx]
                            if (element is Disposable) {
                                element.destroy()
                            }
                        }
                    }
                    is Map<*, *> -> {
                        for (element in arg.values) {
                            if (element is Disposable) {
                                element.destroy()
                            }
                        }
                    }
                    is Iterable<*> -> {
                        for (element in arg) {
                            if (element is Disposable) {
                                element.destroy()
                            }
                        }
                    }
                }
            }
        }
    }
}

/**
 * @suppress
 */
inline fun <T : Disposable?, R> T.use(block: (T) -> R) =
    try {
        block(this)
    } finally {
        try {
            // N.B. our implementation is on the nullable type `Disposable?`.
            this?.destroy()
        } catch (e: Throwable) {
            // swallow
        }
    }

/** 
 * Used to instantiate an interface without an actual pointer, for fakes in tests, mostly.
 *
 * @suppress
 * */
object NoPointer// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
internal const val IDX_CALLBACK_FREE = 0
// Callback return codes
internal const val UNIFFI_CALLBACK_SUCCESS = 0
internal const val UNIFFI_CALLBACK_ERROR = 1
internal const val UNIFFI_CALLBACK_UNEXPECTED_ERROR = 2

/**
 * @suppress
 */
public abstract class FfiConverterCallbackInterface<CallbackInterface: Any>: FfiConverter<CallbackInterface, Long> {
    internal val handleMap = UniffiHandleMap<CallbackInterface>()

    internal fun drop(handle: Long) {
        handleMap.remove(handle)
    }

    override fun lift(value: Long): CallbackInterface {
        return handleMap.get(value)
    }

    override fun read(buf: ByteBuffer) = lift(buf.getLong())

    override fun lower(value: CallbackInterface) = handleMap.insert(value)

    override fun allocationSize(value: CallbackInterface) = 8UL

    override fun write(value: CallbackInterface, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}
/**
 * The cleaner interface for Object finalization code to run.
 * This is the entry point to any implementation that we're using.
 *
 * The cleaner registers objects and returns cleanables, so now we are
 * defining a `UniffiCleaner` with a `UniffiClenaer.Cleanable` to abstract the
 * different implmentations available at compile time.
 *
 * @suppress
 */
interface UniffiCleaner {
    interface Cleanable {
        fun clean()
    }

    fun register(value: Any, cleanUpTask: Runnable): UniffiCleaner.Cleanable

    companion object
}

// The fallback Jna cleaner, which is available for both Android, and the JVM.
private class UniffiJnaCleaner : UniffiCleaner {
    private val cleaner = com.sun.jna.internal.Cleaner.getCleaner()

    override fun register(value: Any, cleanUpTask: Runnable): UniffiCleaner.Cleanable =
        UniffiJnaCleanable(cleaner.register(value, cleanUpTask))
}

private class UniffiJnaCleanable(
    private val cleanable: com.sun.jna.internal.Cleaner.Cleanable,
) : UniffiCleaner.Cleanable {
    override fun clean() = cleanable.clean()
}


// We decide at uniffi binding generation time whether we were
// using Android or not.
// There are further runtime checks to chose the correct implementation
// of the cleaner.
private fun UniffiCleaner.Companion.create(): UniffiCleaner =
    try {
        // For safety's sake: if the library hasn't been run in android_cleaner = true
        // mode, but is being run on Android, then we still need to think about
        // Android API versions.
        // So we check if java.lang.ref.Cleaner is there, and use that…
        java.lang.Class.forName("java.lang.ref.Cleaner")
        JavaLangRefCleaner()
    } catch (e: ClassNotFoundException) {
        // … otherwise, fallback to the JNA cleaner.
        UniffiJnaCleaner()
    }

private class JavaLangRefCleaner : UniffiCleaner {
    val cleaner = java.lang.ref.Cleaner.create()

    override fun register(value: Any, cleanUpTask: Runnable): UniffiCleaner.Cleanable =
        JavaLangRefCleanable(cleaner.register(value, cleanUpTask))
}

private class JavaLangRefCleanable(
    val cleanable: java.lang.ref.Cleaner.Cleanable
) : UniffiCleaner.Cleanable {
    override fun clean() = cleanable.clean()
}

/**
 * @suppress
 */
public object FfiConverterUByte: FfiConverter<UByte, Byte> {
    override fun lift(value: Byte): UByte {
        return value.toUByte()
    }

    override fun read(buf: ByteBuffer): UByte {
        return lift(buf.get())
    }

    override fun lower(value: UByte): Byte {
        return value.toByte()
    }

    override fun allocationSize(value: UByte) = 1UL

    override fun write(value: UByte, buf: ByteBuffer) {
        buf.put(value.toByte())
    }
}

/**
 * @suppress
 */
public object FfiConverterUShort: FfiConverter<UShort, Short> {
    override fun lift(value: Short): UShort {
        return value.toUShort()
    }

    override fun read(buf: ByteBuffer): UShort {
        return lift(buf.getShort())
    }

    override fun lower(value: UShort): Short {
        return value.toShort()
    }

    override fun allocationSize(value: UShort) = 2UL

    override fun write(value: UShort, buf: ByteBuffer) {
        buf.putShort(value.toShort())
    }
}

/**
 * @suppress
 */
public object FfiConverterUInt: FfiConverter<UInt, Int> {
    override fun lift(value: Int): UInt {
        return value.toUInt()
    }

    override fun read(buf: ByteBuffer): UInt {
        return lift(buf.getInt())
    }

    override fun lower(value: UInt): Int {
        return value.toInt()
    }

    override fun allocationSize(value: UInt) = 4UL

    override fun write(value: UInt, buf: ByteBuffer) {
        buf.putInt(value.toInt())
    }
}

/**
 * @suppress
 */
public object FfiConverterInt: FfiConverter<Int, Int> {
    override fun lift(value: Int): Int {
        return value
    }

    override fun read(buf: ByteBuffer): Int {
        return buf.getInt()
    }

    override fun lower(value: Int): Int {
        return value
    }

    override fun allocationSize(value: Int) = 4UL

    override fun write(value: Int, buf: ByteBuffer) {
        buf.putInt(value)
    }
}

/**
 * @suppress
 */
public object FfiConverterULong: FfiConverter<ULong, Long> {
    override fun lift(value: Long): ULong {
        return value.toULong()
    }

    override fun read(buf: ByteBuffer): ULong {
        return lift(buf.getLong())
    }

    override fun lower(value: ULong): Long {
        return value.toLong()
    }

    override fun allocationSize(value: ULong) = 8UL

    override fun write(value: ULong, buf: ByteBuffer) {
        buf.putLong(value.toLong())
    }
}

/**
 * @suppress
 */
public object FfiConverterDouble: FfiConverter<Double, Double> {
    override fun lift(value: Double): Double {
        return value
    }

    override fun read(buf: ByteBuffer): Double {
        return buf.getDouble()
    }

    override fun lower(value: Double): Double {
        return value
    }

    override fun allocationSize(value: Double) = 8UL

    override fun write(value: Double, buf: ByteBuffer) {
        buf.putDouble(value)
    }
}

/**
 * @suppress
 */
public object FfiConverterBoolean: FfiConverter<Boolean, Byte> {
    override fun lift(value: Byte): Boolean {
        return value.toInt() != 0
    }

    override fun read(buf: ByteBuffer): Boolean {
        return lift(buf.get())
    }

    override fun lower(value: Boolean): Byte {
        return if (value) 1.toByte() else 0.toByte()
    }

    override fun allocationSize(value: Boolean) = 1UL

    override fun write(value: Boolean, buf: ByteBuffer) {
        buf.put(lower(value))
    }
}

/**
 * @suppress
 */
public object FfiConverterString: FfiConverter<String, RustBuffer.ByValue> {
    // Note: we don't inherit from FfiConverterRustBuffer, because we use a
    // special encoding when lowering/lifting.  We can use `RustBuffer.len` to
    // store our length and avoid writing it out to the buffer.
    override fun lift(value: RustBuffer.ByValue): String {
        try {
            val byteArr = ByteArray(value.len.toInt())
            value.asByteBuffer()!!.get(byteArr)
            return byteArr.toString(Charsets.UTF_8)
        } finally {
            RustBuffer.free(value)
        }
    }

    override fun read(buf: ByteBuffer): String {
        val len = buf.getInt()
        val byteArr = ByteArray(len)
        buf.get(byteArr)
        return byteArr.toString(Charsets.UTF_8)
    }

    fun toUtf8(value: String): ByteBuffer {
        // Make sure we don't have invalid UTF-16, check for lone surrogates.
        return Charsets.UTF_8.newEncoder().run {
            onMalformedInput(CodingErrorAction.REPORT)
            encode(CharBuffer.wrap(value))
        }
    }

    override fun lower(value: String): RustBuffer.ByValue {
        val byteBuf = toUtf8(value)
        // Ideally we'd pass these bytes to `ffi_bytebuffer_from_bytes`, but doing so would require us
        // to copy them into a JNA `Memory`. So we might as well directly copy them into a `RustBuffer`.
        val rbuf = RustBuffer.alloc(byteBuf.limit().toULong())
        rbuf.asByteBuffer()!!.put(byteBuf)
        return rbuf
    }

    // We aren't sure exactly how many bytes our string will be once it's UTF-8
    // encoded.  Allocate 3 bytes per UTF-16 code unit which will always be
    // enough.
    override fun allocationSize(value: String): ULong {
        val sizeForLength = 4UL
        val sizeForString = value.length.toULong() * 3UL
        return sizeForLength + sizeForString
    }

    override fun write(value: String, buf: ByteBuffer) {
        val byteBuf = toUtf8(value)
        buf.putInt(byteBuf.limit())
        buf.put(byteBuf)
    }
}

/**
 * @suppress
 */
public object FfiConverterByteArray: FfiConverterRustBuffer<ByteArray> {
    override fun read(buf: ByteBuffer): ByteArray {
        val len = buf.getInt()
        val byteArr = ByteArray(len)
        buf.get(byteArr)
        return byteArr
    }
    override fun allocationSize(value: ByteArray): ULong {
        return 4UL + value.size.toULong()
    }
    override fun write(value: ByteArray, buf: ByteBuffer) {
        buf.putInt(value.size)
        buf.put(value)
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface Erc6492ClientInterface {
    
    suspend fun `verifySignature`(`signature`: Bytes, `address`: Address, `messageHash`: B256): kotlin.Boolean
    
    companion object
}

open class Erc6492Client: Disposable, AutoCloseable, Erc6492ClientInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }
    constructor(`rpcUrl`: kotlin.String) :
        this(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_constructor_erc6492client_new(
        FfiConverterString.lower(`rpcUrl`),_status)
}
    )

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_yttrium_fn_free_erc6492client(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_yttrium_fn_clone_erc6492client(pointer!!, status)
        }
    }

    
    @Throws(Erc6492Exception::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `verifySignature`(`signature`: Bytes, `address`: Address, `messageHash`: B256) : kotlin.Boolean {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_yttrium_fn_method_erc6492client_verify_signature(
                thisPtr,
                FfiConverterTypeBytes.lower(`signature`),FfiConverterTypeAddress.lower(`address`),FfiConverterTypeB256.lower(`messageHash`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_poll_i8(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_complete_i8(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_free_i8(future) },
        // lift function
        { FfiConverterBoolean.lift(it) },
        // Error FFI converter
        Erc6492Exception.ErrorHandler,
    )
    }

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypeErc6492Client: FfiConverter<Erc6492Client, Pointer> {

    override fun lower(value: Erc6492Client): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): Erc6492Client {
        return Erc6492Client(value)
    }

    override fun read(buf: ByteBuffer): Erc6492Client {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: Erc6492Client) = 8UL

    override fun write(value: Erc6492Client, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface Logger {
    
    fun `log`(`message`: kotlin.String)
    
    companion object
}

open class LoggerImpl: Disposable, AutoCloseable, Logger
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_yttrium_fn_free_logger(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_yttrium_fn_clone_logger(pointer!!, status)
        }
    }

    override fun `log`(`message`: kotlin.String)
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_method_logger_log(
        it, FfiConverterString.lower(`message`),_status)
}
    }
    
    

    

    
    
    companion object
    
}


// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceLogger {
    internal object `log`: UniffiCallbackInterfaceLoggerMethod0 {
        override fun callback(`uniffiHandle`: Long,`message`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeLogger.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`log`(
                    FfiConverterString.lift(`message`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeLogger.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceLogger.UniffiByValue(
        `log`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_yttrium_fn_init_callback_vtable_logger(vtable)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypeLogger: FfiConverter<Logger, Pointer> {
    internal val handleMap = UniffiHandleMap<Logger>()

    override fun lower(value: Logger): Pointer {
        return Pointer(handleMap.insert(value))
    }

    override fun lift(value: Pointer): Logger {
        return LoggerImpl(value)
    }

    override fun read(buf: ByteBuffer): Logger {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: Logger) = 8UL

    override fun write(value: Logger, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface SignClientInterface {
    
    suspend fun `approve`(`proposal`: SessionProposalFfi, `approvedNamespaces`: Map<kotlin.String, SettleNamespace>, `selfMetadata`: Metadata): SessionFfi
    
    suspend fun `connect`(`params`: ConnectParamsFfi, `selfMetadata`: Metadata): ConnectResultFfi
    
    suspend fun `disconnect`(`topic`: kotlin.String)
    
    suspend fun `extend`(`topic`: kotlin.String)
    
    fun `generateKey`(): kotlin.ByteArray
    
    suspend fun `online`()
    
    suspend fun `pair`(`uri`: kotlin.String): SessionProposalFfi
    
    suspend fun `registerSignListener`(`listener`: SignListener)
    
    suspend fun `reject`(`proposal`: SessionProposalFfi, `reason`: RejectionReason)
    
    suspend fun `request`(`topic`: kotlin.String, `sessionRequest`: SessionRequestFfi): kotlin.ULong
    
    suspend fun `respond`(`topic`: kotlin.String, `response`: SessionRequestJsonRpcResponseFfi): kotlin.String
    
    suspend fun `start`()
    
    suspend fun `update`(`topic`: kotlin.String, `namespaces`: Map<kotlin.String, SettleNamespace>)
    
    companion object
}

open class SignClient: Disposable, AutoCloseable, SignClientInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }
    constructor(`projectId`: kotlin.String, `key`: kotlin.ByteArray, `sessionStore`: StorageFfi) :
        this(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_constructor_signclient_new(
        FfiConverterString.lower(`projectId`),FfiConverterByteArray.lower(`key`),FfiConverterTypeStorageFfi.lower(`sessionStore`),_status)
}
    )

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_yttrium_fn_free_signclient(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_yttrium_fn_clone_signclient(pointer!!, status)
        }
    }

    
    @Throws(ApproveException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `approve`(`proposal`: SessionProposalFfi, `approvedNamespaces`: Map<kotlin.String, SettleNamespace>, `selfMetadata`: Metadata) : SessionFfi {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_yttrium_fn_method_signclient_approve(
                thisPtr,
                FfiConverterTypeSessionProposalFfi.lower(`proposal`),FfiConverterMapStringTypeSettleNamespace.lower(`approvedNamespaces`),FfiConverterTypeMetadata.lower(`selfMetadata`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeSessionFfi.lift(it) },
        // Error FFI converter
        ApproveException.ErrorHandler,
    )
    }

    
    @Throws(ConnectException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `connect`(`params`: ConnectParamsFfi, `selfMetadata`: Metadata) : ConnectResultFfi {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_yttrium_fn_method_signclient_connect(
                thisPtr,
                FfiConverterTypeConnectParamsFfi.lower(`params`),FfiConverterTypeMetadata.lower(`selfMetadata`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeConnectResultFfi.lift(it) },
        // Error FFI converter
        ConnectException.ErrorHandler,
    )
    }

    
    @Throws(DisconnectException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `disconnect`(`topic`: kotlin.String) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_yttrium_fn_method_signclient_disconnect(
                thisPtr,
                FfiConverterString.lower(`topic`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        DisconnectException.ErrorHandler,
    )
    }

    
    @Throws(ExtendException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `extend`(`topic`: kotlin.String) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_yttrium_fn_method_signclient_extend(
                thisPtr,
                FfiConverterString.lower(`topic`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ExtendException.ErrorHandler,
    )
    }

    override fun `generateKey`(): kotlin.ByteArray {
            return FfiConverterByteArray.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_method_signclient_generate_key(
        it, _status)
}
    }
    )
    }
    

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `online`() {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_yttrium_fn_method_signclient_online(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Throws(PairException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `pair`(`uri`: kotlin.String) : SessionProposalFfi {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_yttrium_fn_method_signclient_pair(
                thisPtr,
                FfiConverterString.lower(`uri`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeSessionProposalFfi.lift(it) },
        // Error FFI converter
        PairException.ErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `registerSignListener`(`listener`: SignListener) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_yttrium_fn_method_signclient_register_sign_listener(
                thisPtr,
                FfiConverterTypeSignListener.lower(`listener`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Throws(RejectException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `reject`(`proposal`: SessionProposalFfi, `reason`: RejectionReason) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_yttrium_fn_method_signclient_reject(
                thisPtr,
                FfiConverterTypeSessionProposalFfi.lower(`proposal`),FfiConverterTypeRejectionReason.lower(`reason`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        RejectException.ErrorHandler,
    )
    }

    
    @Throws(RequestException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `request`(`topic`: kotlin.String, `sessionRequest`: SessionRequestFfi) : kotlin.ULong {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_yttrium_fn_method_signclient_request(
                thisPtr,
                FfiConverterString.lower(`topic`),FfiConverterTypeSessionRequestFfi.lower(`sessionRequest`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_poll_u64(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_complete_u64(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_free_u64(future) },
        // lift function
        { FfiConverterULong.lift(it) },
        // Error FFI converter
        RequestException.ErrorHandler,
    )
    }

    
    @Throws(RespondException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `respond`(`topic`: kotlin.String, `response`: SessionRequestJsonRpcResponseFfi) : kotlin.String {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_yttrium_fn_method_signclient_respond(
                thisPtr,
                FfiConverterString.lower(`topic`),FfiConverterTypeSessionRequestJsonRpcResponseFfi.lower(`response`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterString.lift(it) },
        // Error FFI converter
        RespondException.ErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `start`() {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_yttrium_fn_method_signclient_start(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Throws(UpdateException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `update`(`topic`: kotlin.String, `namespaces`: Map<kotlin.String, SettleNamespace>) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_yttrium_fn_method_signclient_update(
                thisPtr,
                FfiConverterString.lower(`topic`),FfiConverterMapStringTypeSettleNamespace.lower(`namespaces`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        UpdateException.ErrorHandler,
    )
    }

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypeSignClient: FfiConverter<SignClient, Pointer> {

    override fun lower(value: SignClient): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): SignClient {
        return SignClient(value)
    }

    override fun read(buf: ByteBuffer): SignClient {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: SignClient) = 8UL

    override fun write(value: SignClient, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface SignListener {
    
    fun `onSessionRequest`(`topic`: kotlin.String, `sessionRequest`: SessionRequestJsonRpcFfi)
    
    fun `onSessionDisconnect`(`id`: kotlin.ULong, `topic`: kotlin.String)
    
    fun `onSessionEvent`(`id`: kotlin.ULong, `topic`: kotlin.String, `params`: kotlin.Boolean)
    
    fun `onSessionExtend`(`id`: kotlin.ULong, `topic`: kotlin.String)
    
    fun `onSessionUpdate`(`id`: kotlin.ULong, `topic`: kotlin.String, `namespaces`: Map<kotlin.String, SettleNamespace>)
    
    fun `onSessionConnect`(`id`: kotlin.ULong)
    
    fun `onSessionRequestResponse`(`id`: kotlin.ULong, `topic`: kotlin.String, `response`: SessionRequestJsonRpcResponseFfi)
    
    companion object
}

open class SignListenerImpl: Disposable, AutoCloseable, SignListener
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_yttrium_fn_free_signlistener(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_yttrium_fn_clone_signlistener(pointer!!, status)
        }
    }

    override fun `onSessionRequest`(`topic`: kotlin.String, `sessionRequest`: SessionRequestJsonRpcFfi)
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_method_signlistener_on_session_request(
        it, FfiConverterString.lower(`topic`),FfiConverterTypeSessionRequestJsonRpcFfi.lower(`sessionRequest`),_status)
}
    }
    
    

    override fun `onSessionDisconnect`(`id`: kotlin.ULong, `topic`: kotlin.String)
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_method_signlistener_on_session_disconnect(
        it, FfiConverterULong.lower(`id`),FfiConverterString.lower(`topic`),_status)
}
    }
    
    

    override fun `onSessionEvent`(`id`: kotlin.ULong, `topic`: kotlin.String, `params`: kotlin.Boolean)
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_method_signlistener_on_session_event(
        it, FfiConverterULong.lower(`id`),FfiConverterString.lower(`topic`),FfiConverterBoolean.lower(`params`),_status)
}
    }
    
    

    override fun `onSessionExtend`(`id`: kotlin.ULong, `topic`: kotlin.String)
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_method_signlistener_on_session_extend(
        it, FfiConverterULong.lower(`id`),FfiConverterString.lower(`topic`),_status)
}
    }
    
    

    override fun `onSessionUpdate`(`id`: kotlin.ULong, `topic`: kotlin.String, `namespaces`: Map<kotlin.String, SettleNamespace>)
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_method_signlistener_on_session_update(
        it, FfiConverterULong.lower(`id`),FfiConverterString.lower(`topic`),FfiConverterMapStringTypeSettleNamespace.lower(`namespaces`),_status)
}
    }
    
    

    override fun `onSessionConnect`(`id`: kotlin.ULong)
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_method_signlistener_on_session_connect(
        it, FfiConverterULong.lower(`id`),_status)
}
    }
    
    

    override fun `onSessionRequestResponse`(`id`: kotlin.ULong, `topic`: kotlin.String, `response`: SessionRequestJsonRpcResponseFfi)
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_method_signlistener_on_session_request_response(
        it, FfiConverterULong.lower(`id`),FfiConverterString.lower(`topic`),FfiConverterTypeSessionRequestJsonRpcResponseFfi.lower(`response`),_status)
}
    }
    
    

    

    
    
    companion object
    
}


// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceSignListener {
    internal object `onSessionRequest`: UniffiCallbackInterfaceSignListenerMethod0 {
        override fun callback(`uniffiHandle`: Long,`topic`: RustBuffer.ByValue,`sessionRequest`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeSignListener.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onSessionRequest`(
                    FfiConverterString.lift(`topic`),
                    FfiConverterTypeSessionRequestJsonRpcFfi.lift(`sessionRequest`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }
    internal object `onSessionDisconnect`: UniffiCallbackInterfaceSignListenerMethod1 {
        override fun callback(`uniffiHandle`: Long,`id`: Long,`topic`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeSignListener.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onSessionDisconnect`(
                    FfiConverterULong.lift(`id`),
                    FfiConverterString.lift(`topic`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }
    internal object `onSessionEvent`: UniffiCallbackInterfaceSignListenerMethod2 {
        override fun callback(`uniffiHandle`: Long,`id`: Long,`topic`: RustBuffer.ByValue,`params`: Byte,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeSignListener.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onSessionEvent`(
                    FfiConverterULong.lift(`id`),
                    FfiConverterString.lift(`topic`),
                    FfiConverterBoolean.lift(`params`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }
    internal object `onSessionExtend`: UniffiCallbackInterfaceSignListenerMethod3 {
        override fun callback(`uniffiHandle`: Long,`id`: Long,`topic`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeSignListener.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onSessionExtend`(
                    FfiConverterULong.lift(`id`),
                    FfiConverterString.lift(`topic`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }
    internal object `onSessionUpdate`: UniffiCallbackInterfaceSignListenerMethod4 {
        override fun callback(`uniffiHandle`: Long,`id`: Long,`topic`: RustBuffer.ByValue,`namespaces`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeSignListener.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onSessionUpdate`(
                    FfiConverterULong.lift(`id`),
                    FfiConverterString.lift(`topic`),
                    FfiConverterMapStringTypeSettleNamespace.lift(`namespaces`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }
    internal object `onSessionConnect`: UniffiCallbackInterfaceSignListenerMethod5 {
        override fun callback(`uniffiHandle`: Long,`id`: Long,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeSignListener.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onSessionConnect`(
                    FfiConverterULong.lift(`id`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }
    internal object `onSessionRequestResponse`: UniffiCallbackInterfaceSignListenerMethod6 {
        override fun callback(`uniffiHandle`: Long,`id`: Long,`topic`: RustBuffer.ByValue,`response`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeSignListener.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onSessionRequestResponse`(
                    FfiConverterULong.lift(`id`),
                    FfiConverterString.lift(`topic`),
                    FfiConverterTypeSessionRequestJsonRpcResponseFfi.lift(`response`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeSignListener.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceSignListener.UniffiByValue(
        `onSessionRequest`,
        `onSessionDisconnect`,
        `onSessionEvent`,
        `onSessionExtend`,
        `onSessionUpdate`,
        `onSessionConnect`,
        `onSessionRequestResponse`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_yttrium_fn_init_callback_vtable_signlistener(vtable)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypeSignListener: FfiConverter<SignListener, Pointer> {
    internal val handleMap = UniffiHandleMap<SignListener>()

    override fun lower(value: SignListener): Pointer {
        return Pointer(handleMap.insert(value))
    }

    override fun lift(value: Pointer): SignListener {
        return SignListenerImpl(value)
    }

    override fun read(buf: ByteBuffer): SignListener {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: SignListener) = 8UL

    override fun write(value: SignListener, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface StacksClientInterface {
    
    suspend fun `getAccount`(`network`: kotlin.String, `principal`: kotlin.String): StacksAccount
    
    suspend fun `transferFees`(`network`: kotlin.String): kotlin.ULong
    
    suspend fun `transferStx`(`wallet`: kotlin.String, `network`: kotlin.String, `request`: TransferStxRequest): TransferStxResponse
    
    companion object
}

open class StacksClient: Disposable, AutoCloseable, StacksClientInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }
    constructor(`projectId`: ProjectId, `pulseMetadata`: PulseMetadata) :
        this(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_constructor_stacksclient_new(
        FfiConverterTypeProjectId.lower(`projectId`),FfiConverterTypePulseMetadata.lower(`pulseMetadata`),_status)
}
    )

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_yttrium_fn_free_stacksclient(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_yttrium_fn_clone_stacksclient(pointer!!, status)
        }
    }

    
    @Throws(StacksAccountException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getAccount`(`network`: kotlin.String, `principal`: kotlin.String) : StacksAccount {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_yttrium_fn_method_stacksclient_get_account(
                thisPtr,
                FfiConverterString.lower(`network`),FfiConverterString.lower(`principal`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeStacksAccount.lift(it) },
        // Error FFI converter
        StacksAccountException.ErrorHandler,
    )
    }

    
    @Throws(StacksFeesException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `transferFees`(`network`: kotlin.String) : kotlin.ULong {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_yttrium_fn_method_stacksclient_transfer_fees(
                thisPtr,
                FfiConverterString.lower(`network`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_poll_u64(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_complete_u64(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_free_u64(future) },
        // lift function
        { FfiConverterULong.lift(it) },
        // Error FFI converter
        StacksFeesException.ErrorHandler,
    )
    }

    
    @Throws(StacksTransferStxException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `transferStx`(`wallet`: kotlin.String, `network`: kotlin.String, `request`: TransferStxRequest) : TransferStxResponse {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_yttrium_fn_method_stacksclient_transfer_stx(
                thisPtr,
                FfiConverterString.lower(`wallet`),FfiConverterString.lower(`network`),FfiConverterTypeTransferStxRequest.lower(`request`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeTransferStxResponse.lift(it) },
        // Error FFI converter
        StacksTransferStxException.ErrorHandler,
    )
    }

    

    
    companion object {
         fun `withBlockchainApiUrl`(`projectId`: ProjectId, `pulseMetadata`: PulseMetadata, `blockchainApiBaseUrl`: Url): StacksClient {
            return FfiConverterTypeStacksClient.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_constructor_stacksclient_with_blockchain_api_url(
        FfiConverterTypeProjectId.lower(`projectId`),FfiConverterTypePulseMetadata.lower(`pulseMetadata`),FfiConverterTypeUrl.lower(`blockchainApiBaseUrl`),_status)
}
    )
    }
    

        
    }
    
}

/**
 * @suppress
 */
public object FfiConverterTypeStacksClient: FfiConverter<StacksClient, Pointer> {

    override fun lower(value: StacksClient): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): StacksClient {
        return StacksClient(value)
    }

    override fun read(buf: ByteBuffer): StacksClient {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: StacksClient) = 8UL

    override fun write(value: StacksClient, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface StorageFfi {
    
    fun `addSession`(`session`: SessionFfi)
    
    fun `deleteSession`(`topic`: kotlin.String)
    
    fun `getSession`(`topic`: kotlin.String): SessionFfi?
    
    fun `getAllSessions`(): List<SessionFfi>
    
    fun `getAllTopics`(): List<Topic>
    
    fun `getDecryptionKeyForTopic`(`topic`: kotlin.String): kotlin.ByteArray?
    
    fun `savePairing`(`topic`: kotlin.String, `rpcId`: kotlin.ULong, `symKey`: kotlin.ByteArray, `selfKey`: kotlin.ByteArray)
    
    fun `getPairing`(`topic`: kotlin.String, `rpcId`: kotlin.ULong): PairingFfi?
    
    fun `savePartialSession`(`topic`: kotlin.String, `symKey`: kotlin.ByteArray)
    
    companion object
}

open class StorageFfiImpl: Disposable, AutoCloseable, StorageFfi
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_yttrium_fn_free_storageffi(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_yttrium_fn_clone_storageffi(pointer!!, status)
        }
    }

    override fun `addSession`(`session`: SessionFfi)
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_method_storageffi_add_session(
        it, FfiConverterTypeSessionFfi.lower(`session`),_status)
}
    }
    
    

    override fun `deleteSession`(`topic`: kotlin.String)
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_method_storageffi_delete_session(
        it, FfiConverterString.lower(`topic`),_status)
}
    }
    
    

    override fun `getSession`(`topic`: kotlin.String): SessionFfi? {
            return FfiConverterOptionalTypeSessionFfi.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_method_storageffi_get_session(
        it, FfiConverterString.lower(`topic`),_status)
}
    }
    )
    }
    

    override fun `getAllSessions`(): List<SessionFfi> {
            return FfiConverterSequenceTypeSessionFfi.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_method_storageffi_get_all_sessions(
        it, _status)
}
    }
    )
    }
    

    override fun `getAllTopics`(): List<Topic> {
            return FfiConverterSequenceTypeTopic.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_method_storageffi_get_all_topics(
        it, _status)
}
    }
    )
    }
    

    override fun `getDecryptionKeyForTopic`(`topic`: kotlin.String): kotlin.ByteArray? {
            return FfiConverterOptionalByteArray.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_method_storageffi_get_decryption_key_for_topic(
        it, FfiConverterString.lower(`topic`),_status)
}
    }
    )
    }
    

    override fun `savePairing`(`topic`: kotlin.String, `rpcId`: kotlin.ULong, `symKey`: kotlin.ByteArray, `selfKey`: kotlin.ByteArray)
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_method_storageffi_save_pairing(
        it, FfiConverterString.lower(`topic`),FfiConverterULong.lower(`rpcId`),FfiConverterByteArray.lower(`symKey`),FfiConverterByteArray.lower(`selfKey`),_status)
}
    }
    
    

    override fun `getPairing`(`topic`: kotlin.String, `rpcId`: kotlin.ULong): PairingFfi? {
            return FfiConverterOptionalTypePairingFfi.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_method_storageffi_get_pairing(
        it, FfiConverterString.lower(`topic`),FfiConverterULong.lower(`rpcId`),_status)
}
    }
    )
    }
    

    override fun `savePartialSession`(`topic`: kotlin.String, `symKey`: kotlin.ByteArray)
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_method_storageffi_save_partial_session(
        it, FfiConverterString.lower(`topic`),FfiConverterByteArray.lower(`symKey`),_status)
}
    }
    
    

    

    
    
    companion object
    
}


// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceStorageFfi {
    internal object `addSession`: UniffiCallbackInterfaceStorageFfiMethod0 {
        override fun callback(`uniffiHandle`: Long,`session`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeStorageFfi.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`addSession`(
                    FfiConverterTypeSessionFfi.lift(`session`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }
    internal object `deleteSession`: UniffiCallbackInterfaceStorageFfiMethod1 {
        override fun callback(`uniffiHandle`: Long,`topic`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeStorageFfi.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`deleteSession`(
                    FfiConverterString.lift(`topic`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }
    internal object `getSession`: UniffiCallbackInterfaceStorageFfiMethod2 {
        override fun callback(`uniffiHandle`: Long,`topic`: RustBuffer.ByValue,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeStorageFfi.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`getSession`(
                    FfiConverterString.lift(`topic`),
                )
            }
            val writeReturn = { value: SessionFfi? -> uniffiOutReturn.setValue(FfiConverterOptionalTypeSessionFfi.lower(value)) }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }
    internal object `getAllSessions`: UniffiCallbackInterfaceStorageFfiMethod3 {
        override fun callback(`uniffiHandle`: Long,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeStorageFfi.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`getAllSessions`(
                )
            }
            val writeReturn = { value: List<SessionFfi> -> uniffiOutReturn.setValue(FfiConverterSequenceTypeSessionFfi.lower(value)) }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }
    internal object `getAllTopics`: UniffiCallbackInterfaceStorageFfiMethod4 {
        override fun callback(`uniffiHandle`: Long,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeStorageFfi.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`getAllTopics`(
                )
            }
            val writeReturn = { value: List<Topic> -> uniffiOutReturn.setValue(FfiConverterSequenceTypeTopic.lower(value)) }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }
    internal object `getDecryptionKeyForTopic`: UniffiCallbackInterfaceStorageFfiMethod5 {
        override fun callback(`uniffiHandle`: Long,`topic`: RustBuffer.ByValue,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeStorageFfi.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`getDecryptionKeyForTopic`(
                    FfiConverterString.lift(`topic`),
                )
            }
            val writeReturn = { value: kotlin.ByteArray? -> uniffiOutReturn.setValue(FfiConverterOptionalByteArray.lower(value)) }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }
    internal object `savePairing`: UniffiCallbackInterfaceStorageFfiMethod6 {
        override fun callback(`uniffiHandle`: Long,`topic`: RustBuffer.ByValue,`rpcId`: Long,`symKey`: RustBuffer.ByValue,`selfKey`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeStorageFfi.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`savePairing`(
                    FfiConverterString.lift(`topic`),
                    FfiConverterULong.lift(`rpcId`),
                    FfiConverterByteArray.lift(`symKey`),
                    FfiConverterByteArray.lift(`selfKey`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }
    internal object `getPairing`: UniffiCallbackInterfaceStorageFfiMethod7 {
        override fun callback(`uniffiHandle`: Long,`topic`: RustBuffer.ByValue,`rpcId`: Long,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeStorageFfi.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`getPairing`(
                    FfiConverterString.lift(`topic`),
                    FfiConverterULong.lift(`rpcId`),
                )
            }
            val writeReturn = { value: PairingFfi? -> uniffiOutReturn.setValue(FfiConverterOptionalTypePairingFfi.lower(value)) }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }
    internal object `savePartialSession`: UniffiCallbackInterfaceStorageFfiMethod8 {
        override fun callback(`uniffiHandle`: Long,`topic`: RustBuffer.ByValue,`symKey`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeStorageFfi.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`savePartialSession`(
                    FfiConverterString.lift(`topic`),
                    FfiConverterByteArray.lift(`symKey`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeStorageFfi.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceStorageFfi.UniffiByValue(
        `addSession`,
        `deleteSession`,
        `getSession`,
        `getAllSessions`,
        `getAllTopics`,
        `getDecryptionKeyForTopic`,
        `savePairing`,
        `getPairing`,
        `savePartialSession`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_yttrium_fn_init_callback_vtable_storageffi(vtable)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypeStorageFfi: FfiConverter<StorageFfi, Pointer> {
    internal val handleMap = UniffiHandleMap<StorageFfi>()

    override fun lower(value: StorageFfi): Pointer {
        return Pointer(handleMap.insert(value))
    }

    override fun lift(value: Pointer): StorageFfi {
        return StorageFfiImpl(value)
    }

    override fun read(buf: ByteBuffer): StorageFfi {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: StorageFfi) = 8UL

    override fun write(value: StorageFfi, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface SuiClientInterface {
    
    suspend fun `getAllBalances`(`chainId`: kotlin.String, `address`: SuiAddress): List<Balance>
    
    suspend fun `signAndExecuteTransaction`(`chainId`: kotlin.String, `keypair`: SuiKeyPair, `txData`: kotlin.ByteArray): TransactionDigest
    
    suspend fun `signTransaction`(`chainId`: kotlin.String, `keypair`: SuiKeyPair, `txData`: kotlin.ByteArray): SignTransactionResult
    
    companion object
}

open class SuiClient: Disposable, AutoCloseable, SuiClientInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }
    constructor(`projectId`: ProjectId, `pulseMetadata`: PulseMetadata) :
        this(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_constructor_suiclient_new(
        FfiConverterTypeProjectId.lower(`projectId`),FfiConverterTypePulseMetadata.lower(`pulseMetadata`),_status)
}
    )

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_yttrium_fn_free_suiclient(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_yttrium_fn_clone_suiclient(pointer!!, status)
        }
    }

    
    @Throws(SuiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getAllBalances`(`chainId`: kotlin.String, `address`: SuiAddress) : List<Balance> {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_yttrium_fn_method_suiclient_get_all_balances(
                thisPtr,
                FfiConverterString.lower(`chainId`),FfiConverterTypeSuiAddress.lower(`address`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterSequenceTypeBalance.lift(it) },
        // Error FFI converter
        SuiException.ErrorHandler,
    )
    }

    
    @Throws(SuiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `signAndExecuteTransaction`(`chainId`: kotlin.String, `keypair`: SuiKeyPair, `txData`: kotlin.ByteArray) : TransactionDigest {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_yttrium_fn_method_suiclient_sign_and_execute_transaction(
                thisPtr,
                FfiConverterString.lower(`chainId`),FfiConverterTypeSuiKeyPair.lower(`keypair`),FfiConverterByteArray.lower(`txData`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeTransactionDigest.lift(it) },
        // Error FFI converter
        SuiException.ErrorHandler,
    )
    }

    
    @Throws(SuiException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `signTransaction`(`chainId`: kotlin.String, `keypair`: SuiKeyPair, `txData`: kotlin.ByteArray) : SignTransactionResult {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_yttrium_fn_method_suiclient_sign_transaction(
                thisPtr,
                FfiConverterString.lower(`chainId`),FfiConverterTypeSuiKeyPair.lower(`keypair`),FfiConverterByteArray.lower(`txData`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_yttrium_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeSignTransactionResult.lift(it) },
        // Error FFI converter
        SuiException.ErrorHandler,
    )
    }

    

    
    companion object {
         fun `withBlockchainApiUrl`(`projectId`: ProjectId, `pulseMetadata`: PulseMetadata, `blockchainApiBaseUrl`: Url): SuiClient {
            return FfiConverterTypeSuiClient.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_constructor_suiclient_with_blockchain_api_url(
        FfiConverterTypeProjectId.lower(`projectId`),FfiConverterTypePulseMetadata.lower(`pulseMetadata`),FfiConverterTypeUrl.lower(`blockchainApiBaseUrl`),_status)
}
    )
    }
    

        
    }
    
}

/**
 * @suppress
 */
public object FfiConverterTypeSuiClient: FfiConverter<SuiClient, Pointer> {

    override fun lower(value: SuiClient): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): SuiClient {
        return SuiClient(value)
    }

    override fun read(buf: ByteBuffer): SuiClient {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: SuiClient) = 8UL

    override fun write(value: SuiClient, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}



data class Amount (
    var `symbol`: kotlin.String, 
    var `amount`: U256, 
    var `unit`: kotlin.UByte, 
    var `formatted`: kotlin.String, 
    /**
     * Special case that assumes the currency is USD and `unit` is at least 2 decimals
     */
    var `formattedAlt`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAmount: FfiConverterRustBuffer<Amount> {
    override fun read(buf: ByteBuffer): Amount {
        return Amount(
            FfiConverterString.read(buf),
            FfiConverterTypeU256.read(buf),
            FfiConverterUByte.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: Amount) = (
            FfiConverterString.allocationSize(value.`symbol`) +
            FfiConverterTypeU256.allocationSize(value.`amount`) +
            FfiConverterUByte.allocationSize(value.`unit`) +
            FfiConverterString.allocationSize(value.`formatted`) +
            FfiConverterString.allocationSize(value.`formattedAlt`)
    )

    override fun write(value: Amount, buf: ByteBuffer) {
            FfiConverterString.write(value.`symbol`, buf)
            FfiConverterTypeU256.write(value.`amount`, buf)
            FfiConverterUByte.write(value.`unit`, buf)
            FfiConverterString.write(value.`formatted`, buf)
            FfiConverterString.write(value.`formattedAlt`, buf)
    }
}



data class BalanceFfi (
    var `coinType`: kotlin.String, 
    var `totalBalance`: kotlin.ULong
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeBalanceFfi: FfiConverterRustBuffer<BalanceFfi> {
    override fun read(buf: ByteBuffer): BalanceFfi {
        return BalanceFfi(
            FfiConverterString.read(buf),
            FfiConverterULong.read(buf),
        )
    }

    override fun allocationSize(value: BalanceFfi) = (
            FfiConverterString.allocationSize(value.`coinType`) +
            FfiConverterULong.allocationSize(value.`totalBalance`)
    )

    override fun write(value: BalanceFfi, buf: ByteBuffer) {
            FfiConverterString.write(value.`coinType`, buf)
            FfiConverterULong.write(value.`totalBalance`, buf)
    }
}



data class Call (
    var `to`: Address, 
    var `value`: U256, 
    var `input`: Bytes
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeCall: FfiConverterRustBuffer<Call> {
    override fun read(buf: ByteBuffer): Call {
        return Call(
            FfiConverterTypeAddress.read(buf),
            FfiConverterTypeU256.read(buf),
            FfiConverterTypeBytes.read(buf),
        )
    }

    override fun allocationSize(value: Call) = (
            FfiConverterTypeAddress.allocationSize(value.`to`) +
            FfiConverterTypeU256.allocationSize(value.`value`) +
            FfiConverterTypeBytes.allocationSize(value.`input`)
    )

    override fun write(value: Call, buf: ByteBuffer) {
            FfiConverterTypeAddress.write(value.`to`, buf)
            FfiConverterTypeU256.write(value.`value`, buf)
            FfiConverterTypeBytes.write(value.`input`, buf)
    }
}



data class Config (
    var `endpoints`: Endpoints
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeConfig: FfiConverterRustBuffer<Config> {
    override fun read(buf: ByteBuffer): Config {
        return Config(
            FfiConverterTypeEndpoints.read(buf),
        )
    }

    override fun allocationSize(value: Config) = (
            FfiConverterTypeEndpoints.allocationSize(value.`endpoints`)
    )

    override fun write(value: Config, buf: ByteBuffer) {
            FfiConverterTypeEndpoints.write(value.`endpoints`, buf)
    }
}



data class ConnectParams (
    var `optionalNamespaces`: Map<kotlin.String, ProposalNamespace>, 
    var `sessionProperties`: Map<kotlin.String, kotlin.String>?, 
    var `scopedProperties`: Map<kotlin.String, kotlin.String>?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeConnectParams: FfiConverterRustBuffer<ConnectParams> {
    override fun read(buf: ByteBuffer): ConnectParams {
        return ConnectParams(
            FfiConverterMapStringTypeProposalNamespace.read(buf),
            FfiConverterOptionalMapStringString.read(buf),
            FfiConverterOptionalMapStringString.read(buf),
        )
    }

    override fun allocationSize(value: ConnectParams) = (
            FfiConverterMapStringTypeProposalNamespace.allocationSize(value.`optionalNamespaces`) +
            FfiConverterOptionalMapStringString.allocationSize(value.`sessionProperties`) +
            FfiConverterOptionalMapStringString.allocationSize(value.`scopedProperties`)
    )

    override fun write(value: ConnectParams, buf: ByteBuffer) {
            FfiConverterMapStringTypeProposalNamespace.write(value.`optionalNamespaces`, buf)
            FfiConverterOptionalMapStringString.write(value.`sessionProperties`, buf)
            FfiConverterOptionalMapStringString.write(value.`scopedProperties`, buf)
    }
}



data class ConnectParamsFfi (
    var `optionalNamespaces`: Map<kotlin.String, ProposalNamespace>, 
    var `sessionProperties`: Map<kotlin.String, kotlin.String>?, 
    var `scopedProperties`: Map<kotlin.String, kotlin.String>?, 
    var `metadata`: Metadata
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeConnectParamsFfi: FfiConverterRustBuffer<ConnectParamsFfi> {
    override fun read(buf: ByteBuffer): ConnectParamsFfi {
        return ConnectParamsFfi(
            FfiConverterMapStringTypeProposalNamespace.read(buf),
            FfiConverterOptionalMapStringString.read(buf),
            FfiConverterOptionalMapStringString.read(buf),
            FfiConverterTypeMetadata.read(buf),
        )
    }

    override fun allocationSize(value: ConnectParamsFfi) = (
            FfiConverterMapStringTypeProposalNamespace.allocationSize(value.`optionalNamespaces`) +
            FfiConverterOptionalMapStringString.allocationSize(value.`sessionProperties`) +
            FfiConverterOptionalMapStringString.allocationSize(value.`scopedProperties`) +
            FfiConverterTypeMetadata.allocationSize(value.`metadata`)
    )

    override fun write(value: ConnectParamsFfi, buf: ByteBuffer) {
            FfiConverterMapStringTypeProposalNamespace.write(value.`optionalNamespaces`, buf)
            FfiConverterOptionalMapStringString.write(value.`sessionProperties`, buf)
            FfiConverterOptionalMapStringString.write(value.`scopedProperties`, buf)
            FfiConverterTypeMetadata.write(value.`metadata`, buf)
    }
}



data class ConnectResult (
    var `topic`: Topic, 
    var `uri`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeConnectResult: FfiConverterRustBuffer<ConnectResult> {
    override fun read(buf: ByteBuffer): ConnectResult {
        return ConnectResult(
            FfiConverterTypeTopic.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: ConnectResult) = (
            FfiConverterTypeTopic.allocationSize(value.`topic`) +
            FfiConverterString.allocationSize(value.`uri`)
    )

    override fun write(value: ConnectResult, buf: ByteBuffer) {
            FfiConverterTypeTopic.write(value.`topic`, buf)
            FfiConverterString.write(value.`uri`, buf)
    }
}



data class ConnectResultFfi (
    var `topic`: Topic, 
    var `uri`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeConnectResultFfi: FfiConverterRustBuffer<ConnectResultFfi> {
    override fun read(buf: ByteBuffer): ConnectResultFfi {
        return ConnectResultFfi(
            FfiConverterTypeTopic.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: ConnectResultFfi) = (
            FfiConverterTypeTopic.allocationSize(value.`topic`) +
            FfiConverterString.allocationSize(value.`uri`)
    )

    override fun write(value: ConnectResultFfi, buf: ByteBuffer) {
            FfiConverterTypeTopic.write(value.`topic`, buf)
            FfiConverterString.write(value.`uri`, buf)
    }
}



data class DoSendTransactionParams (
    var `userOp`: UserOperationV07, 
    var `validAfter`: U48, 
    var `validUntil`: U48
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDoSendTransactionParams: FfiConverterRustBuffer<DoSendTransactionParams> {
    override fun read(buf: ByteBuffer): DoSendTransactionParams {
        return DoSendTransactionParams(
            FfiConverterTypeUserOperationV07.read(buf),
            FfiConverterTypeU48.read(buf),
            FfiConverterTypeU48.read(buf),
        )
    }

    override fun allocationSize(value: DoSendTransactionParams) = (
            FfiConverterTypeUserOperationV07.allocationSize(value.`userOp`) +
            FfiConverterTypeU48.allocationSize(value.`validAfter`) +
            FfiConverterTypeU48.allocationSize(value.`validUntil`)
    )

    override fun write(value: DoSendTransactionParams, buf: ByteBuffer) {
            FfiConverterTypeUserOperationV07.write(value.`userOp`, buf)
            FfiConverterTypeU48.write(value.`validAfter`, buf)
            FfiConverterTypeU48.write(value.`validUntil`, buf)
    }
}



data class Endpoint (
    var `baseUrl`: kotlin.String, 
    var `apiKey`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeEndpoint: FfiConverterRustBuffer<Endpoint> {
    override fun read(buf: ByteBuffer): Endpoint {
        return Endpoint(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: Endpoint) = (
            FfiConverterString.allocationSize(value.`baseUrl`) +
            FfiConverterString.allocationSize(value.`apiKey`)
    )

    override fun write(value: Endpoint, buf: ByteBuffer) {
            FfiConverterString.write(value.`baseUrl`, buf)
            FfiConverterString.write(value.`apiKey`, buf)
    }
}



data class Endpoints (
    var `rpc`: Endpoint, 
    var `bundler`: Endpoint, 
    var `paymaster`: Endpoint
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeEndpoints: FfiConverterRustBuffer<Endpoints> {
    override fun read(buf: ByteBuffer): Endpoints {
        return Endpoints(
            FfiConverterTypeEndpoint.read(buf),
            FfiConverterTypeEndpoint.read(buf),
            FfiConverterTypeEndpoint.read(buf),
        )
    }

    override fun allocationSize(value: Endpoints) = (
            FfiConverterTypeEndpoint.allocationSize(value.`rpc`) +
            FfiConverterTypeEndpoint.allocationSize(value.`bundler`) +
            FfiConverterTypeEndpoint.allocationSize(value.`paymaster`)
    )

    override fun write(value: Endpoints, buf: ByteBuffer) {
            FfiConverterTypeEndpoint.write(value.`rpc`, buf)
            FfiConverterTypeEndpoint.write(value.`bundler`, buf)
            FfiConverterTypeEndpoint.write(value.`paymaster`, buf)
    }
}



data class Erc20Metadata (
    var `name`: kotlin.String, 
    var `symbol`: kotlin.String, 
    var `decimals`: kotlin.UByte, 
    var `value`: kotlin.Double?, 
    var `price`: kotlin.Double, 
    var `iconUrl`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeErc20Metadata: FfiConverterRustBuffer<Erc20Metadata> {
    override fun read(buf: ByteBuffer): Erc20Metadata {
        return Erc20Metadata(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterUByte.read(buf),
            FfiConverterOptionalDouble.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: Erc20Metadata) = (
            FfiConverterString.allocationSize(value.`name`) +
            FfiConverterString.allocationSize(value.`symbol`) +
            FfiConverterUByte.allocationSize(value.`decimals`) +
            FfiConverterOptionalDouble.allocationSize(value.`value`) +
            FfiConverterDouble.allocationSize(value.`price`) +
            FfiConverterString.allocationSize(value.`iconUrl`)
    )

    override fun write(value: Erc20Metadata, buf: ByteBuffer) {
            FfiConverterString.write(value.`name`, buf)
            FfiConverterString.write(value.`symbol`, buf)
            FfiConverterUByte.write(value.`decimals`, buf)
            FfiConverterOptionalDouble.write(value.`value`, buf)
            FfiConverterDouble.write(value.`price`, buf)
            FfiConverterString.write(value.`iconUrl`, buf)
    }
}



data class Erc721Metadata (
    var `name`: kotlin.String, 
    var `symbol`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeErc721Metadata: FfiConverterRustBuffer<Erc721Metadata> {
    override fun read(buf: ByteBuffer): Erc721Metadata {
        return Erc721Metadata(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: Erc721Metadata) = (
            FfiConverterString.allocationSize(value.`name`) +
            FfiConverterString.allocationSize(value.`symbol`)
    )

    override fun write(value: Erc721Metadata, buf: ByteBuffer) {
            FfiConverterString.write(value.`name`, buf)
            FfiConverterString.write(value.`symbol`, buf)
    }
}



data class ErrorDataFfi (
    /**
     * Error code.
     */
    var `code`: kotlin.Int, 
    /**
     * Error message.
     */
    var `message`: kotlin.String, 
    /**
     * Error data, if any.
     */
    var `data`: kotlin.String?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeErrorDataFfi: FfiConverterRustBuffer<ErrorDataFfi> {
    override fun read(buf: ByteBuffer): ErrorDataFfi {
        return ErrorDataFfi(
            FfiConverterInt.read(buf),
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: ErrorDataFfi) = (
            FfiConverterInt.allocationSize(value.`code`) +
            FfiConverterString.allocationSize(value.`message`) +
            FfiConverterOptionalString.allocationSize(value.`data`)
    )

    override fun write(value: ErrorDataFfi, buf: ByteBuffer) {
            FfiConverterInt.write(value.`code`, buf)
            FfiConverterString.write(value.`message`, buf)
            FfiConverterOptionalString.write(value.`data`, buf)
    }
}



data class EstimatedCost (
    var `readCount`: kotlin.ULong, 
    var `readLength`: kotlin.ULong, 
    var `runtime`: kotlin.ULong, 
    var `writeCount`: kotlin.ULong, 
    var `writeLength`: kotlin.ULong
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeEstimatedCost: FfiConverterRustBuffer<EstimatedCost> {
    override fun read(buf: ByteBuffer): EstimatedCost {
        return EstimatedCost(
            FfiConverterULong.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterULong.read(buf),
        )
    }

    override fun allocationSize(value: EstimatedCost) = (
            FfiConverterULong.allocationSize(value.`readCount`) +
            FfiConverterULong.allocationSize(value.`readLength`) +
            FfiConverterULong.allocationSize(value.`runtime`) +
            FfiConverterULong.allocationSize(value.`writeCount`) +
            FfiConverterULong.allocationSize(value.`writeLength`)
    )

    override fun write(value: EstimatedCost, buf: ByteBuffer) {
            FfiConverterULong.write(value.`readCount`, buf)
            FfiConverterULong.write(value.`readLength`, buf)
            FfiConverterULong.write(value.`runtime`, buf)
            FfiConverterULong.write(value.`writeCount`, buf)
            FfiConverterULong.write(value.`writeLength`, buf)
    }
}



data class Estimation (
    var `fee`: kotlin.ULong, 
    var `feeRate`: kotlin.Double
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeEstimation: FfiConverterRustBuffer<Estimation> {
    override fun read(buf: ByteBuffer): Estimation {
        return Estimation(
            FfiConverterULong.read(buf),
            FfiConverterDouble.read(buf),
        )
    }

    override fun allocationSize(value: Estimation) = (
            FfiConverterULong.allocationSize(value.`fee`) +
            FfiConverterDouble.allocationSize(value.`feeRate`)
    )

    override fun write(value: Estimation, buf: ByteBuffer) {
            FfiConverterULong.write(value.`fee`, buf)
            FfiConverterDouble.write(value.`feeRate`, buf)
    }
}



data class ExecuteDetails (
    var `initialTxnReceipt`: TransactionReceipt, 
    var `initialTxnHash`: B256
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeExecuteDetails: FfiConverterRustBuffer<ExecuteDetails> {
    override fun read(buf: ByteBuffer): ExecuteDetails {
        return ExecuteDetails(
            FfiConverterTypeTransactionReceipt.read(buf),
            FfiConverterTypeB256.read(buf),
        )
    }

    override fun allocationSize(value: ExecuteDetails) = (
            FfiConverterTypeTransactionReceipt.allocationSize(value.`initialTxnReceipt`) +
            FfiConverterTypeB256.allocationSize(value.`initialTxnHash`)
    )

    override fun write(value: ExecuteDetails, buf: ByteBuffer) {
            FfiConverterTypeTransactionReceipt.write(value.`initialTxnReceipt`, buf)
            FfiConverterTypeB256.write(value.`initialTxnHash`, buf)
    }
}



data class FeeEstimatedTransaction (
    var `chainId`: kotlin.String, 
    var `from`: Address, 
    var `to`: Address, 
    var `value`: U256, 
    var `input`: Bytes, 
    var `gasLimit`: U64, 
    var `nonce`: U64, 
    var `maxFeePerGas`: U128, 
    var `maxPriorityFeePerGas`: U128
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeFeeEstimatedTransaction: FfiConverterRustBuffer<FeeEstimatedTransaction> {
    override fun read(buf: ByteBuffer): FeeEstimatedTransaction {
        return FeeEstimatedTransaction(
            FfiConverterString.read(buf),
            FfiConverterTypeAddress.read(buf),
            FfiConverterTypeAddress.read(buf),
            FfiConverterTypeU256.read(buf),
            FfiConverterTypeBytes.read(buf),
            FfiConverterTypeU64.read(buf),
            FfiConverterTypeU64.read(buf),
            FfiConverterTypeU128.read(buf),
            FfiConverterTypeU128.read(buf),
        )
    }

    override fun allocationSize(value: FeeEstimatedTransaction) = (
            FfiConverterString.allocationSize(value.`chainId`) +
            FfiConverterTypeAddress.allocationSize(value.`from`) +
            FfiConverterTypeAddress.allocationSize(value.`to`) +
            FfiConverterTypeU256.allocationSize(value.`value`) +
            FfiConverterTypeBytes.allocationSize(value.`input`) +
            FfiConverterTypeU64.allocationSize(value.`gasLimit`) +
            FfiConverterTypeU64.allocationSize(value.`nonce`) +
            FfiConverterTypeU128.allocationSize(value.`maxFeePerGas`) +
            FfiConverterTypeU128.allocationSize(value.`maxPriorityFeePerGas`)
    )

    override fun write(value: FeeEstimatedTransaction, buf: ByteBuffer) {
            FfiConverterString.write(value.`chainId`, buf)
            FfiConverterTypeAddress.write(value.`from`, buf)
            FfiConverterTypeAddress.write(value.`to`, buf)
            FfiConverterTypeU256.write(value.`value`, buf)
            FfiConverterTypeBytes.write(value.`input`, buf)
            FfiConverterTypeU64.write(value.`gasLimit`, buf)
            FfiConverterTypeU64.write(value.`nonce`, buf)
            FfiConverterTypeU128.write(value.`maxFeePerGas`, buf)
            FfiConverterTypeU128.write(value.`maxPriorityFeePerGas`, buf)
    }
}



data class FeeEstimation (
    var `costScalarChangeByByte`: kotlin.Double, 
    var `estimatedCost`: EstimatedCost, 
    var `estimatedCostScalar`: kotlin.ULong, 
    var `estimations`: List<Estimation>
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeFeeEstimation: FfiConverterRustBuffer<FeeEstimation> {
    override fun read(buf: ByteBuffer): FeeEstimation {
        return FeeEstimation(
            FfiConverterDouble.read(buf),
            FfiConverterTypeEstimatedCost.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterSequenceTypeEstimation.read(buf),
        )
    }

    override fun allocationSize(value: FeeEstimation) = (
            FfiConverterDouble.allocationSize(value.`costScalarChangeByByte`) +
            FfiConverterTypeEstimatedCost.allocationSize(value.`estimatedCost`) +
            FfiConverterULong.allocationSize(value.`estimatedCostScalar`) +
            FfiConverterSequenceTypeEstimation.allocationSize(value.`estimations`)
    )

    override fun write(value: FeeEstimation, buf: ByteBuffer) {
            FfiConverterDouble.write(value.`costScalarChangeByByte`, buf)
            FfiConverterTypeEstimatedCost.write(value.`estimatedCost`, buf)
            FfiConverterULong.write(value.`estimatedCostScalar`, buf)
            FfiConverterSequenceTypeEstimation.write(value.`estimations`, buf)
    }
}



data class FfiAuthorization (
    /**
     * The chain ID of the authorization.
     */
    var `chainId`: U256, 
    /**
     * The address of the authorization.
     */
    var `address`: Address, 
    /**
     * The nonce for the authorization.
     */
    var `nonce`: kotlin.ULong
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeFfiAuthorization: FfiConverterRustBuffer<FfiAuthorization> {
    override fun read(buf: ByteBuffer): FfiAuthorization {
        return FfiAuthorization(
            FfiConverterTypeU256.read(buf),
            FfiConverterTypeAddress.read(buf),
            FfiConverterULong.read(buf),
        )
    }

    override fun allocationSize(value: FfiAuthorization) = (
            FfiConverterTypeU256.allocationSize(value.`chainId`) +
            FfiConverterTypeAddress.allocationSize(value.`address`) +
            FfiConverterULong.allocationSize(value.`nonce`)
    )

    override fun write(value: FfiAuthorization, buf: ByteBuffer) {
            FfiConverterTypeU256.write(value.`chainId`, buf)
            FfiConverterTypeAddress.write(value.`address`, buf)
            FfiConverterULong.write(value.`nonce`, buf)
    }
}



data class FundingMetadata (
    var `chainId`: kotlin.String, 
    var `tokenContract`: Eip155OrSolanaAddress, 
    var `symbol`: kotlin.String, 
    var `amount`: U256, 
    var `bridgingFee`: U256, 
    var `decimals`: kotlin.UByte
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeFundingMetadata: FfiConverterRustBuffer<FundingMetadata> {
    override fun read(buf: ByteBuffer): FundingMetadata {
        return FundingMetadata(
            FfiConverterString.read(buf),
            FfiConverterTypeEip155OrSolanaAddress.read(buf),
            FfiConverterString.read(buf),
            FfiConverterTypeU256.read(buf),
            FfiConverterTypeU256.read(buf),
            FfiConverterUByte.read(buf),
        )
    }

    override fun allocationSize(value: FundingMetadata) = (
            FfiConverterString.allocationSize(value.`chainId`) +
            FfiConverterTypeEip155OrSolanaAddress.allocationSize(value.`tokenContract`) +
            FfiConverterString.allocationSize(value.`symbol`) +
            FfiConverterTypeU256.allocationSize(value.`amount`) +
            FfiConverterTypeU256.allocationSize(value.`bridgingFee`) +
            FfiConverterUByte.allocationSize(value.`decimals`)
    )

    override fun write(value: FundingMetadata, buf: ByteBuffer) {
            FfiConverterString.write(value.`chainId`, buf)
            FfiConverterTypeEip155OrSolanaAddress.write(value.`tokenContract`, buf)
            FfiConverterString.write(value.`symbol`, buf)
            FfiConverterTypeU256.write(value.`amount`, buf)
            FfiConverterTypeU256.write(value.`bridgingFee`, buf)
            FfiConverterUByte.write(value.`decimals`, buf)
    }
}



data class GetAssetsFilters (
    var `assetFilter`: Map<U64, List<AddressOrNative>>?, 
    var `assetTypeFilter`: List<AssetType>?, 
    var `chainFilter`: List<U64>?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeGetAssetsFilters: FfiConverterRustBuffer<GetAssetsFilters> {
    override fun read(buf: ByteBuffer): GetAssetsFilters {
        return GetAssetsFilters(
            FfiConverterOptionalMapTypeU64SequenceTypeAddressOrNative.read(buf),
            FfiConverterOptionalSequenceTypeAssetType.read(buf),
            FfiConverterOptionalSequenceTypeU64.read(buf),
        )
    }

    override fun allocationSize(value: GetAssetsFilters) = (
            FfiConverterOptionalMapTypeU64SequenceTypeAddressOrNative.allocationSize(value.`assetFilter`) +
            FfiConverterOptionalSequenceTypeAssetType.allocationSize(value.`assetTypeFilter`) +
            FfiConverterOptionalSequenceTypeU64.allocationSize(value.`chainFilter`)
    )

    override fun write(value: GetAssetsFilters, buf: ByteBuffer) {
            FfiConverterOptionalMapTypeU64SequenceTypeAddressOrNative.write(value.`assetFilter`, buf)
            FfiConverterOptionalSequenceTypeAssetType.write(value.`assetTypeFilter`, buf)
            FfiConverterOptionalSequenceTypeU64.write(value.`chainFilter`, buf)
    }
}



data class GetAssetsParams (
    var `account`: Address, 
    var `filters`: GetAssetsFilters
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeGetAssetsParams: FfiConverterRustBuffer<GetAssetsParams> {
    override fun read(buf: ByteBuffer): GetAssetsParams {
        return GetAssetsParams(
            FfiConverterTypeAddress.read(buf),
            FfiConverterTypeGetAssetsFilters.read(buf),
        )
    }

    override fun allocationSize(value: GetAssetsParams) = (
            FfiConverterTypeAddress.allocationSize(value.`account`) +
            FfiConverterTypeGetAssetsFilters.allocationSize(value.`filters`)
    )

    override fun write(value: GetAssetsParams, buf: ByteBuffer) {
            FfiConverterTypeAddress.write(value.`account`, buf)
            FfiConverterTypeGetAssetsFilters.write(value.`filters`, buf)
    }
}



data class InitialTransactionMetadata (
    var `transferTo`: Address, 
    var `amount`: U256, 
    var `tokenContract`: Address, 
    var `symbol`: kotlin.String, 
    var `decimals`: kotlin.UByte
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeInitialTransactionMetadata: FfiConverterRustBuffer<InitialTransactionMetadata> {
    override fun read(buf: ByteBuffer): InitialTransactionMetadata {
        return InitialTransactionMetadata(
            FfiConverterTypeAddress.read(buf),
            FfiConverterTypeU256.read(buf),
            FfiConverterTypeAddress.read(buf),
            FfiConverterString.read(buf),
            FfiConverterUByte.read(buf),
        )
    }

    override fun allocationSize(value: InitialTransactionMetadata) = (
            FfiConverterTypeAddress.allocationSize(value.`transferTo`) +
            FfiConverterTypeU256.allocationSize(value.`amount`) +
            FfiConverterTypeAddress.allocationSize(value.`tokenContract`) +
            FfiConverterString.allocationSize(value.`symbol`) +
            FfiConverterUByte.allocationSize(value.`decimals`)
    )

    override fun write(value: InitialTransactionMetadata, buf: ByteBuffer) {
            FfiConverterTypeAddress.write(value.`transferTo`, buf)
            FfiConverterTypeU256.write(value.`amount`, buf)
            FfiConverterTypeAddress.write(value.`tokenContract`, buf)
            FfiConverterString.write(value.`symbol`, buf)
            FfiConverterUByte.write(value.`decimals`, buf)
    }
}



data class Metadata (
    var `name`: kotlin.String, 
    var `description`: kotlin.String, 
    var `url`: kotlin.String, 
    var `icons`: List<kotlin.String>, 
    var `verifyUrl`: kotlin.String?, 
    var `redirect`: Redirect?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMetadata: FfiConverterRustBuffer<Metadata> {
    override fun read(buf: ByteBuffer): Metadata {
        return Metadata(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterSequenceString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalTypeRedirect.read(buf),
        )
    }

    override fun allocationSize(value: Metadata) = (
            FfiConverterString.allocationSize(value.`name`) +
            FfiConverterString.allocationSize(value.`description`) +
            FfiConverterString.allocationSize(value.`url`) +
            FfiConverterSequenceString.allocationSize(value.`icons`) +
            FfiConverterOptionalString.allocationSize(value.`verifyUrl`) +
            FfiConverterOptionalTypeRedirect.allocationSize(value.`redirect`)
    )

    override fun write(value: Metadata, buf: ByteBuffer) {
            FfiConverterString.write(value.`name`, buf)
            FfiConverterString.write(value.`description`, buf)
            FfiConverterString.write(value.`url`, buf)
            FfiConverterSequenceString.write(value.`icons`, buf)
            FfiConverterOptionalString.write(value.`verifyUrl`, buf)
            FfiConverterOptionalTypeRedirect.write(value.`redirect`, buf)
    }
}



data class NativeMetadata (
    var `name`: kotlin.String, 
    var `symbol`: kotlin.String, 
    var `decimals`: kotlin.UByte, 
    var `value`: kotlin.Double?, 
    var `price`: kotlin.Double, 
    var `iconUrl`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeNativeMetadata: FfiConverterRustBuffer<NativeMetadata> {
    override fun read(buf: ByteBuffer): NativeMetadata {
        return NativeMetadata(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterUByte.read(buf),
            FfiConverterOptionalDouble.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: NativeMetadata) = (
            FfiConverterString.allocationSize(value.`name`) +
            FfiConverterString.allocationSize(value.`symbol`) +
            FfiConverterUByte.allocationSize(value.`decimals`) +
            FfiConverterOptionalDouble.allocationSize(value.`value`) +
            FfiConverterDouble.allocationSize(value.`price`) +
            FfiConverterString.allocationSize(value.`iconUrl`)
    )

    override fun write(value: NativeMetadata, buf: ByteBuffer) {
            FfiConverterString.write(value.`name`, buf)
            FfiConverterString.write(value.`symbol`, buf)
            FfiConverterUByte.write(value.`decimals`, buf)
            FfiConverterOptionalDouble.write(value.`value`, buf)
            FfiConverterDouble.write(value.`price`, buf)
            FfiConverterString.write(value.`iconUrl`, buf)
    }
}



data class OwnerSignature (
    var `owner`: Address, 
    var `signature`: PrimitiveSignature
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeOwnerSignature: FfiConverterRustBuffer<OwnerSignature> {
    override fun read(buf: ByteBuffer): OwnerSignature {
        return OwnerSignature(
            FfiConverterTypeAddress.read(buf),
            FfiConverterTypePrimitiveSignature.read(buf),
        )
    }

    override fun allocationSize(value: OwnerSignature) = (
            FfiConverterTypeAddress.allocationSize(value.`owner`) +
            FfiConverterTypePrimitiveSignature.allocationSize(value.`signature`)
    )

    override fun write(value: OwnerSignature, buf: ByteBuffer) {
            FfiConverterTypeAddress.write(value.`owner`, buf)
            FfiConverterTypePrimitiveSignature.write(value.`signature`, buf)
    }
}



data class Pairing (
    var `topic`: kotlin.String, 
    var `uri`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePairing: FfiConverterRustBuffer<Pairing> {
    override fun read(buf: ByteBuffer): Pairing {
        return Pairing(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: Pairing) = (
            FfiConverterString.allocationSize(value.`topic`) +
            FfiConverterString.allocationSize(value.`uri`)
    )

    override fun write(value: Pairing, buf: ByteBuffer) {
            FfiConverterString.write(value.`topic`, buf)
            FfiConverterString.write(value.`uri`, buf)
    }
}



data class PairingFfi (
    var `rpcId`: kotlin.ULong, 
    var `symKey`: kotlin.ByteArray, 
    var `selfKey`: kotlin.ByteArray
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePairingFfi: FfiConverterRustBuffer<PairingFfi> {
    override fun read(buf: ByteBuffer): PairingFfi {
        return PairingFfi(
            FfiConverterULong.read(buf),
            FfiConverterByteArray.read(buf),
            FfiConverterByteArray.read(buf),
        )
    }

    override fun allocationSize(value: PairingFfi) = (
            FfiConverterULong.allocationSize(value.`rpcId`) +
            FfiConverterByteArray.allocationSize(value.`symKey`) +
            FfiConverterByteArray.allocationSize(value.`selfKey`)
    )

    override fun write(value: PairingFfi, buf: ByteBuffer) {
            FfiConverterULong.write(value.`rpcId`, buf)
            FfiConverterByteArray.write(value.`symKey`, buf)
            FfiConverterByteArray.write(value.`selfKey`, buf)
    }
}



data class PairingInfo (
    var `topic`: Topic, 
    var `uri`: kotlin.String, 
    var `symKey`: kotlin.ByteArray, 
    var `expiry`: kotlin.ULong, 
    var `relay`: Relay, 
    var `active`: kotlin.Boolean, 
    var `methods`: List<kotlin.String>?, 
    var `peerMetadata`: Metadata?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePairingInfo: FfiConverterRustBuffer<PairingInfo> {
    override fun read(buf: ByteBuffer): PairingInfo {
        return PairingInfo(
            FfiConverterTypeTopic.read(buf),
            FfiConverterString.read(buf),
            FfiConverterByteArray.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterTypeRelay.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterOptionalSequenceString.read(buf),
            FfiConverterOptionalTypeMetadata.read(buf),
        )
    }

    override fun allocationSize(value: PairingInfo) = (
            FfiConverterTypeTopic.allocationSize(value.`topic`) +
            FfiConverterString.allocationSize(value.`uri`) +
            FfiConverterByteArray.allocationSize(value.`symKey`) +
            FfiConverterULong.allocationSize(value.`expiry`) +
            FfiConverterTypeRelay.allocationSize(value.`relay`) +
            FfiConverterBoolean.allocationSize(value.`active`) +
            FfiConverterOptionalSequenceString.allocationSize(value.`methods`) +
            FfiConverterOptionalTypeMetadata.allocationSize(value.`peerMetadata`)
    )

    override fun write(value: PairingInfo, buf: ByteBuffer) {
            FfiConverterTypeTopic.write(value.`topic`, buf)
            FfiConverterString.write(value.`uri`, buf)
            FfiConverterByteArray.write(value.`symKey`, buf)
            FfiConverterULong.write(value.`expiry`, buf)
            FfiConverterTypeRelay.write(value.`relay`, buf)
            FfiConverterBoolean.write(value.`active`, buf)
            FfiConverterOptionalSequenceString.write(value.`methods`, buf)
            FfiConverterOptionalTypeMetadata.write(value.`peerMetadata`, buf)
    }
}



data class PrepareResponseAvailable (
    var `orchestrationId`: kotlin.String, 
    var `initialTransaction`: Transaction, 
    var `transactions`: List<Transactions>, 
    var `metadata`: PrepareResponseMetadata
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePrepareResponseAvailable: FfiConverterRustBuffer<PrepareResponseAvailable> {
    override fun read(buf: ByteBuffer): PrepareResponseAvailable {
        return PrepareResponseAvailable(
            FfiConverterString.read(buf),
            FfiConverterTypeTransaction.read(buf),
            FfiConverterSequenceTypeTransactions.read(buf),
            FfiConverterTypePrepareResponseMetadata.read(buf),
        )
    }

    override fun allocationSize(value: PrepareResponseAvailable) = (
            FfiConverterString.allocationSize(value.`orchestrationId`) +
            FfiConverterTypeTransaction.allocationSize(value.`initialTransaction`) +
            FfiConverterSequenceTypeTransactions.allocationSize(value.`transactions`) +
            FfiConverterTypePrepareResponseMetadata.allocationSize(value.`metadata`)
    )

    override fun write(value: PrepareResponseAvailable, buf: ByteBuffer) {
            FfiConverterString.write(value.`orchestrationId`, buf)
            FfiConverterTypeTransaction.write(value.`initialTransaction`, buf)
            FfiConverterSequenceTypeTransactions.write(value.`transactions`, buf)
            FfiConverterTypePrepareResponseMetadata.write(value.`metadata`, buf)
    }
}



/**
 * Bridging check error response that should be returned as a normal HTTP 200
 * response
 */
data class PrepareResponseError (
    var `error`: BridgingError, 
    var `reason`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePrepareResponseError: FfiConverterRustBuffer<PrepareResponseError> {
    override fun read(buf: ByteBuffer): PrepareResponseError {
        return PrepareResponseError(
            FfiConverterTypeBridgingError.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: PrepareResponseError) = (
            FfiConverterTypeBridgingError.allocationSize(value.`error`) +
            FfiConverterString.allocationSize(value.`reason`)
    )

    override fun write(value: PrepareResponseError, buf: ByteBuffer) {
            FfiConverterTypeBridgingError.write(value.`error`, buf)
            FfiConverterString.write(value.`reason`, buf)
    }
}



data class PrepareResponseMetadata (
    var `fundingFrom`: List<FundingMetadata>, 
    var `initialTransaction`: InitialTransactionMetadata, 
    /**
     * The number of milliseconds to delay before calling `/status` after getting successful transaction receipts from all sent transactions.
     * Not switching to Duration yet because Kotlin maps this to a native `duration` type but this requires API version 26 but we support 23.
     * https://reown-inc.slack.com/archives/C07HQ8RCGD8/p1738740204879269
     */
    var `checkIn`: kotlin.ULong
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePrepareResponseMetadata: FfiConverterRustBuffer<PrepareResponseMetadata> {
    override fun read(buf: ByteBuffer): PrepareResponseMetadata {
        return PrepareResponseMetadata(
            FfiConverterSequenceTypeFundingMetadata.read(buf),
            FfiConverterTypeInitialTransactionMetadata.read(buf),
            FfiConverterULong.read(buf),
        )
    }

    override fun allocationSize(value: PrepareResponseMetadata) = (
            FfiConverterSequenceTypeFundingMetadata.allocationSize(value.`fundingFrom`) +
            FfiConverterTypeInitialTransactionMetadata.allocationSize(value.`initialTransaction`) +
            FfiConverterULong.allocationSize(value.`checkIn`)
    )

    override fun write(value: PrepareResponseMetadata, buf: ByteBuffer) {
            FfiConverterSequenceTypeFundingMetadata.write(value.`fundingFrom`, buf)
            FfiConverterTypeInitialTransactionMetadata.write(value.`initialTransaction`, buf)
            FfiConverterULong.write(value.`checkIn`, buf)
    }
}



data class PrepareResponseNotRequired (
    var `initialTransaction`: Transaction, 
    var `transactions`: List<Transaction>
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePrepareResponseNotRequired: FfiConverterRustBuffer<PrepareResponseNotRequired> {
    override fun read(buf: ByteBuffer): PrepareResponseNotRequired {
        return PrepareResponseNotRequired(
            FfiConverterTypeTransaction.read(buf),
            FfiConverterSequenceTypeTransaction.read(buf),
        )
    }

    override fun allocationSize(value: PrepareResponseNotRequired) = (
            FfiConverterTypeTransaction.allocationSize(value.`initialTransaction`) +
            FfiConverterSequenceTypeTransaction.allocationSize(value.`transactions`)
    )

    override fun write(value: PrepareResponseNotRequired, buf: ByteBuffer) {
            FfiConverterTypeTransaction.write(value.`initialTransaction`, buf)
            FfiConverterSequenceTypeTransaction.write(value.`transactions`, buf)
    }
}



data class PreparedSendTransaction (
    var `safeOp`: SafeOp, 
    var `domain`: Eip712Domain, 
    var `hash`: B256, 
    var `doSendTransactionParams`: DoSendTransactionParams
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePreparedSendTransaction: FfiConverterRustBuffer<PreparedSendTransaction> {
    override fun read(buf: ByteBuffer): PreparedSendTransaction {
        return PreparedSendTransaction(
            FfiConverterTypeSafeOp.read(buf),
            FfiConverterTypeEip712Domain.read(buf),
            FfiConverterTypeB256.read(buf),
            FfiConverterTypeDoSendTransactionParams.read(buf),
        )
    }

    override fun allocationSize(value: PreparedSendTransaction) = (
            FfiConverterTypeSafeOp.allocationSize(value.`safeOp`) +
            FfiConverterTypeEip712Domain.allocationSize(value.`domain`) +
            FfiConverterTypeB256.allocationSize(value.`hash`) +
            FfiConverterTypeDoSendTransactionParams.allocationSize(value.`doSendTransactionParams`)
    )

    override fun write(value: PreparedSendTransaction, buf: ByteBuffer) {
            FfiConverterTypeSafeOp.write(value.`safeOp`, buf)
            FfiConverterTypeEip712Domain.write(value.`domain`, buf)
            FfiConverterTypeB256.write(value.`hash`, buf)
            FfiConverterTypeDoSendTransactionParams.write(value.`doSendTransactionParams`, buf)
    }
}



data class ProposalNamespace (
    var `chains`: List<kotlin.String>, 
    var `methods`: List<kotlin.String>, 
    var `events`: List<kotlin.String>
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeProposalNamespace: FfiConverterRustBuffer<ProposalNamespace> {
    override fun read(buf: ByteBuffer): ProposalNamespace {
        return ProposalNamespace(
            FfiConverterSequenceString.read(buf),
            FfiConverterSequenceString.read(buf),
            FfiConverterSequenceString.read(buf),
        )
    }

    override fun allocationSize(value: ProposalNamespace) = (
            FfiConverterSequenceString.allocationSize(value.`chains`) +
            FfiConverterSequenceString.allocationSize(value.`methods`) +
            FfiConverterSequenceString.allocationSize(value.`events`)
    )

    override fun write(value: ProposalNamespace, buf: ByteBuffer) {
            FfiConverterSequenceString.write(value.`chains`, buf)
            FfiConverterSequenceString.write(value.`methods`, buf)
            FfiConverterSequenceString.write(value.`events`, buf)
    }
}



data class PulseMetadata (
    var `url`: Url?, 
    var `bundleId`: kotlin.String?, 
    var `sdkVersion`: kotlin.String, 
    var `sdkPlatform`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePulseMetadata: FfiConverterRustBuffer<PulseMetadata> {
    override fun read(buf: ByteBuffer): PulseMetadata {
        return PulseMetadata(
            FfiConverterOptionalTypeUrl.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: PulseMetadata) = (
            FfiConverterOptionalTypeUrl.allocationSize(value.`url`) +
            FfiConverterOptionalString.allocationSize(value.`bundleId`) +
            FfiConverterString.allocationSize(value.`sdkVersion`) +
            FfiConverterString.allocationSize(value.`sdkPlatform`)
    )

    override fun write(value: PulseMetadata, buf: ByteBuffer) {
            FfiConverterOptionalTypeUrl.write(value.`url`, buf)
            FfiConverterOptionalString.write(value.`bundleId`, buf)
            FfiConverterString.write(value.`sdkVersion`, buf)
            FfiConverterString.write(value.`sdkPlatform`, buf)
    }
}



data class Redirect (
    var `native`: kotlin.String?, 
    var `universal`: kotlin.String?, 
    var `linkMode`: kotlin.Boolean
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeRedirect: FfiConverterRustBuffer<Redirect> {
    override fun read(buf: ByteBuffer): Redirect {
        return Redirect(
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: Redirect) = (
            FfiConverterOptionalString.allocationSize(value.`native`) +
            FfiConverterOptionalString.allocationSize(value.`universal`) +
            FfiConverterBoolean.allocationSize(value.`linkMode`)
    )

    override fun write(value: Redirect, buf: ByteBuffer) {
            FfiConverterOptionalString.write(value.`native`, buf)
            FfiConverterOptionalString.write(value.`universal`, buf)
            FfiConverterBoolean.write(value.`linkMode`, buf)
    }
}



data class Relay (
    var `protocol`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeRelay: FfiConverterRustBuffer<Relay> {
    override fun read(buf: ByteBuffer): Relay {
        return Relay(
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: Relay) = (
            FfiConverterString.allocationSize(value.`protocol`)
    )

    override fun write(value: Relay, buf: ByteBuffer) {
            FfiConverterString.write(value.`protocol`, buf)
    }
}



/**
 * ```solidity
 * struct SafeOp { address safe; uint256 nonce; bytes initCode; bytes callData; uint128 verificationGasLimit; uint128 callGasLimit; uint256 preVerificationGas; uint128 maxPriorityFeePerGas; uint128 maxFeePerGas; bytes paymasterAndData; uint48 validAfter; uint48 validUntil; address entryPoint; }
 * ```
 */
data class SafeOp (
    var `safe`: Address, 
    var `nonce`: U256, 
    var `initCode`: Bytes, 
    var `callData`: Bytes, 
    var `verificationGasLimit`: U128Primitive, 
    var `callGasLimit`: U128Primitive, 
    var `preVerificationGas`: U256, 
    var `maxPriorityFeePerGas`: U128Primitive, 
    var `maxFeePerGas`: U128Primitive, 
    var `paymasterAndData`: Bytes, 
    var `validAfter`: U48, 
    var `validUntil`: U48, 
    var `entryPoint`: Address
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSafeOp: FfiConverterRustBuffer<SafeOp> {
    override fun read(buf: ByteBuffer): SafeOp {
        return SafeOp(
            FfiConverterTypeAddress.read(buf),
            FfiConverterTypeU256.read(buf),
            FfiConverterTypeBytes.read(buf),
            FfiConverterTypeBytes.read(buf),
            FfiConverterTypeU128Primitive.read(buf),
            FfiConverterTypeU128Primitive.read(buf),
            FfiConverterTypeU256.read(buf),
            FfiConverterTypeU128Primitive.read(buf),
            FfiConverterTypeU128Primitive.read(buf),
            FfiConverterTypeBytes.read(buf),
            FfiConverterTypeU48.read(buf),
            FfiConverterTypeU48.read(buf),
            FfiConverterTypeAddress.read(buf),
        )
    }

    override fun allocationSize(value: SafeOp) = (
            FfiConverterTypeAddress.allocationSize(value.`safe`) +
            FfiConverterTypeU256.allocationSize(value.`nonce`) +
            FfiConverterTypeBytes.allocationSize(value.`initCode`) +
            FfiConverterTypeBytes.allocationSize(value.`callData`) +
            FfiConverterTypeU128Primitive.allocationSize(value.`verificationGasLimit`) +
            FfiConverterTypeU128Primitive.allocationSize(value.`callGasLimit`) +
            FfiConverterTypeU256.allocationSize(value.`preVerificationGas`) +
            FfiConverterTypeU128Primitive.allocationSize(value.`maxPriorityFeePerGas`) +
            FfiConverterTypeU128Primitive.allocationSize(value.`maxFeePerGas`) +
            FfiConverterTypeBytes.allocationSize(value.`paymasterAndData`) +
            FfiConverterTypeU48.allocationSize(value.`validAfter`) +
            FfiConverterTypeU48.allocationSize(value.`validUntil`) +
            FfiConverterTypeAddress.allocationSize(value.`entryPoint`)
    )

    override fun write(value: SafeOp, buf: ByteBuffer) {
            FfiConverterTypeAddress.write(value.`safe`, buf)
            FfiConverterTypeU256.write(value.`nonce`, buf)
            FfiConverterTypeBytes.write(value.`initCode`, buf)
            FfiConverterTypeBytes.write(value.`callData`, buf)
            FfiConverterTypeU128Primitive.write(value.`verificationGasLimit`, buf)
            FfiConverterTypeU128Primitive.write(value.`callGasLimit`, buf)
            FfiConverterTypeU256.write(value.`preVerificationGas`, buf)
            FfiConverterTypeU128Primitive.write(value.`maxPriorityFeePerGas`, buf)
            FfiConverterTypeU128Primitive.write(value.`maxFeePerGas`, buf)
            FfiConverterTypeBytes.write(value.`paymasterAndData`, buf)
            FfiConverterTypeU48.write(value.`validAfter`, buf)
            FfiConverterTypeU48.write(value.`validUntil`, buf)
            FfiConverterTypeAddress.write(value.`entryPoint`, buf)
    }
}



data class SessionDelete (
    var `code`: kotlin.ULong, 
    var `message`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSessionDelete: FfiConverterRustBuffer<SessionDelete> {
    override fun read(buf: ByteBuffer): SessionDelete {
        return SessionDelete(
            FfiConverterULong.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: SessionDelete) = (
            FfiConverterULong.allocationSize(value.`code`) +
            FfiConverterString.allocationSize(value.`message`)
    )

    override fun write(value: SessionDelete, buf: ByteBuffer) {
            FfiConverterULong.write(value.`code`, buf)
            FfiConverterString.write(value.`message`, buf)
    }
}



data class SessionDeleteJsonRpc (
    var `id`: kotlin.ULong, 
    var `jsonrpc`: kotlin.String, 
    var `method`: kotlin.String, 
    var `params`: SessionDelete
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSessionDeleteJsonRpc: FfiConverterRustBuffer<SessionDeleteJsonRpc> {
    override fun read(buf: ByteBuffer): SessionDeleteJsonRpc {
        return SessionDeleteJsonRpc(
            FfiConverterULong.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterTypeSessionDelete.read(buf),
        )
    }

    override fun allocationSize(value: SessionDeleteJsonRpc) = (
            FfiConverterULong.allocationSize(value.`id`) +
            FfiConverterString.allocationSize(value.`jsonrpc`) +
            FfiConverterString.allocationSize(value.`method`) +
            FfiConverterTypeSessionDelete.allocationSize(value.`params`)
    )

    override fun write(value: SessionDeleteJsonRpc, buf: ByteBuffer) {
            FfiConverterULong.write(value.`id`, buf)
            FfiConverterString.write(value.`jsonrpc`, buf)
            FfiConverterString.write(value.`method`, buf)
            FfiConverterTypeSessionDelete.write(value.`params`, buf)
    }
}



data class SessionFfi (
    var `requestId`: kotlin.ULong, 
    var `sessionSymKey`: kotlin.ByteArray, 
    var `selfPublicKey`: kotlin.ByteArray, 
    var `topic`: Topic, 
    var `expiry`: kotlin.ULong, 
    var `relayProtocol`: kotlin.String, 
    var `relayData`: kotlin.String?, 
    var `controllerKey`: kotlin.ByteArray?, 
    var `selfMetaData`: Metadata, 
    var `peerPublicKey`: kotlin.ByteArray?, 
    var `peerMetaData`: Metadata?, 
    var `sessionNamespaces`: Map<kotlin.String, SettleNamespace>, 
    var `requiredNamespaces`: Map<kotlin.String, ProposalNamespace>, 
    var `optionalNamespaces`: Map<kotlin.String, ProposalNamespace>?, 
    var `properties`: Map<kotlin.String, kotlin.String>?, 
    var `scopedProperties`: Map<kotlin.String, kotlin.String>?, 
    var `isAcknowledged`: kotlin.Boolean, 
    var `pairingTopic`: kotlin.String, 
    var `transportType`: TransportType?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSessionFfi: FfiConverterRustBuffer<SessionFfi> {
    override fun read(buf: ByteBuffer): SessionFfi {
        return SessionFfi(
            FfiConverterULong.read(buf),
            FfiConverterByteArray.read(buf),
            FfiConverterByteArray.read(buf),
            FfiConverterTypeTopic.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalByteArray.read(buf),
            FfiConverterTypeMetadata.read(buf),
            FfiConverterOptionalByteArray.read(buf),
            FfiConverterOptionalTypeMetadata.read(buf),
            FfiConverterMapStringTypeSettleNamespace.read(buf),
            FfiConverterMapStringTypeProposalNamespace.read(buf),
            FfiConverterOptionalMapStringTypeProposalNamespace.read(buf),
            FfiConverterOptionalMapStringString.read(buf),
            FfiConverterOptionalMapStringString.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterString.read(buf),
            FfiConverterOptionalTypeTransportType.read(buf),
        )
    }

    override fun allocationSize(value: SessionFfi) = (
            FfiConverterULong.allocationSize(value.`requestId`) +
            FfiConverterByteArray.allocationSize(value.`sessionSymKey`) +
            FfiConverterByteArray.allocationSize(value.`selfPublicKey`) +
            FfiConverterTypeTopic.allocationSize(value.`topic`) +
            FfiConverterULong.allocationSize(value.`expiry`) +
            FfiConverterString.allocationSize(value.`relayProtocol`) +
            FfiConverterOptionalString.allocationSize(value.`relayData`) +
            FfiConverterOptionalByteArray.allocationSize(value.`controllerKey`) +
            FfiConverterTypeMetadata.allocationSize(value.`selfMetaData`) +
            FfiConverterOptionalByteArray.allocationSize(value.`peerPublicKey`) +
            FfiConverterOptionalTypeMetadata.allocationSize(value.`peerMetaData`) +
            FfiConverterMapStringTypeSettleNamespace.allocationSize(value.`sessionNamespaces`) +
            FfiConverterMapStringTypeProposalNamespace.allocationSize(value.`requiredNamespaces`) +
            FfiConverterOptionalMapStringTypeProposalNamespace.allocationSize(value.`optionalNamespaces`) +
            FfiConverterOptionalMapStringString.allocationSize(value.`properties`) +
            FfiConverterOptionalMapStringString.allocationSize(value.`scopedProperties`) +
            FfiConverterBoolean.allocationSize(value.`isAcknowledged`) +
            FfiConverterString.allocationSize(value.`pairingTopic`) +
            FfiConverterOptionalTypeTransportType.allocationSize(value.`transportType`)
    )

    override fun write(value: SessionFfi, buf: ByteBuffer) {
            FfiConverterULong.write(value.`requestId`, buf)
            FfiConverterByteArray.write(value.`sessionSymKey`, buf)
            FfiConverterByteArray.write(value.`selfPublicKey`, buf)
            FfiConverterTypeTopic.write(value.`topic`, buf)
            FfiConverterULong.write(value.`expiry`, buf)
            FfiConverterString.write(value.`relayProtocol`, buf)
            FfiConverterOptionalString.write(value.`relayData`, buf)
            FfiConverterOptionalByteArray.write(value.`controllerKey`, buf)
            FfiConverterTypeMetadata.write(value.`selfMetaData`, buf)
            FfiConverterOptionalByteArray.write(value.`peerPublicKey`, buf)
            FfiConverterOptionalTypeMetadata.write(value.`peerMetaData`, buf)
            FfiConverterMapStringTypeSettleNamespace.write(value.`sessionNamespaces`, buf)
            FfiConverterMapStringTypeProposalNamespace.write(value.`requiredNamespaces`, buf)
            FfiConverterOptionalMapStringTypeProposalNamespace.write(value.`optionalNamespaces`, buf)
            FfiConverterOptionalMapStringString.write(value.`properties`, buf)
            FfiConverterOptionalMapStringString.write(value.`scopedProperties`, buf)
            FfiConverterBoolean.write(value.`isAcknowledged`, buf)
            FfiConverterString.write(value.`pairingTopic`, buf)
            FfiConverterOptionalTypeTransportType.write(value.`transportType`, buf)
    }
}



data class SessionProposalFfi (
    var `id`: kotlin.String, 
    var `topic`: kotlin.String, 
    var `pairingSymKey`: kotlin.ByteArray, 
    var `proposerPublicKey`: kotlin.ByteArray, 
    var `relays`: List<Relay>, 
    var `requiredNamespaces`: Map<kotlin.String, ProposalNamespace>, 
    var `optionalNamespaces`: Map<kotlin.String, ProposalNamespace>?, 
    var `metadata`: Metadata, 
    var `sessionProperties`: Map<kotlin.String, kotlin.String>?, 
    var `scopedProperties`: Map<kotlin.String, kotlin.String>?, 
    var `expiryTimestamp`: kotlin.ULong?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSessionProposalFfi: FfiConverterRustBuffer<SessionProposalFfi> {
    override fun read(buf: ByteBuffer): SessionProposalFfi {
        return SessionProposalFfi(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterByteArray.read(buf),
            FfiConverterByteArray.read(buf),
            FfiConverterSequenceTypeRelay.read(buf),
            FfiConverterMapStringTypeProposalNamespace.read(buf),
            FfiConverterOptionalMapStringTypeProposalNamespace.read(buf),
            FfiConverterTypeMetadata.read(buf),
            FfiConverterOptionalMapStringString.read(buf),
            FfiConverterOptionalMapStringString.read(buf),
            FfiConverterOptionalULong.read(buf),
        )
    }

    override fun allocationSize(value: SessionProposalFfi) = (
            FfiConverterString.allocationSize(value.`id`) +
            FfiConverterString.allocationSize(value.`topic`) +
            FfiConverterByteArray.allocationSize(value.`pairingSymKey`) +
            FfiConverterByteArray.allocationSize(value.`proposerPublicKey`) +
            FfiConverterSequenceTypeRelay.allocationSize(value.`relays`) +
            FfiConverterMapStringTypeProposalNamespace.allocationSize(value.`requiredNamespaces`) +
            FfiConverterOptionalMapStringTypeProposalNamespace.allocationSize(value.`optionalNamespaces`) +
            FfiConverterTypeMetadata.allocationSize(value.`metadata`) +
            FfiConverterOptionalMapStringString.allocationSize(value.`sessionProperties`) +
            FfiConverterOptionalMapStringString.allocationSize(value.`scopedProperties`) +
            FfiConverterOptionalULong.allocationSize(value.`expiryTimestamp`)
    )

    override fun write(value: SessionProposalFfi, buf: ByteBuffer) {
            FfiConverterString.write(value.`id`, buf)
            FfiConverterString.write(value.`topic`, buf)
            FfiConverterByteArray.write(value.`pairingSymKey`, buf)
            FfiConverterByteArray.write(value.`proposerPublicKey`, buf)
            FfiConverterSequenceTypeRelay.write(value.`relays`, buf)
            FfiConverterMapStringTypeProposalNamespace.write(value.`requiredNamespaces`, buf)
            FfiConverterOptionalMapStringTypeProposalNamespace.write(value.`optionalNamespaces`, buf)
            FfiConverterTypeMetadata.write(value.`metadata`, buf)
            FfiConverterOptionalMapStringString.write(value.`sessionProperties`, buf)
            FfiConverterOptionalMapStringString.write(value.`scopedProperties`, buf)
            FfiConverterOptionalULong.write(value.`expiryTimestamp`, buf)
    }
}



data class SessionRequestFfi (
    var `chainId`: kotlin.String, 
    var `request`: SessionRequestRequestFfi
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSessionRequestFfi: FfiConverterRustBuffer<SessionRequestFfi> {
    override fun read(buf: ByteBuffer): SessionRequestFfi {
        return SessionRequestFfi(
            FfiConverterString.read(buf),
            FfiConverterTypeSessionRequestRequestFfi.read(buf),
        )
    }

    override fun allocationSize(value: SessionRequestFfi) = (
            FfiConverterString.allocationSize(value.`chainId`) +
            FfiConverterTypeSessionRequestRequestFfi.allocationSize(value.`request`)
    )

    override fun write(value: SessionRequestFfi, buf: ByteBuffer) {
            FfiConverterString.write(value.`chainId`, buf)
            FfiConverterTypeSessionRequestRequestFfi.write(value.`request`, buf)
    }
}



data class SessionRequestJsonRpcErrorResponseFfi (
    var `id`: kotlin.ULong, 
    var `jsonrpc`: kotlin.String, 
    var `error`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSessionRequestJsonRpcErrorResponseFfi: FfiConverterRustBuffer<SessionRequestJsonRpcErrorResponseFfi> {
    override fun read(buf: ByteBuffer): SessionRequestJsonRpcErrorResponseFfi {
        return SessionRequestJsonRpcErrorResponseFfi(
            FfiConverterULong.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: SessionRequestJsonRpcErrorResponseFfi) = (
            FfiConverterULong.allocationSize(value.`id`) +
            FfiConverterString.allocationSize(value.`jsonrpc`) +
            FfiConverterString.allocationSize(value.`error`)
    )

    override fun write(value: SessionRequestJsonRpcErrorResponseFfi, buf: ByteBuffer) {
            FfiConverterULong.write(value.`id`, buf)
            FfiConverterString.write(value.`jsonrpc`, buf)
            FfiConverterString.write(value.`error`, buf)
    }
}



data class SessionRequestJsonRpcFfi (
    var `id`: kotlin.ULong, 
    var `method`: kotlin.String, 
    var `params`: SessionRequestFfi
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSessionRequestJsonRpcFfi: FfiConverterRustBuffer<SessionRequestJsonRpcFfi> {
    override fun read(buf: ByteBuffer): SessionRequestJsonRpcFfi {
        return SessionRequestJsonRpcFfi(
            FfiConverterULong.read(buf),
            FfiConverterString.read(buf),
            FfiConverterTypeSessionRequestFfi.read(buf),
        )
    }

    override fun allocationSize(value: SessionRequestJsonRpcFfi) = (
            FfiConverterULong.allocationSize(value.`id`) +
            FfiConverterString.allocationSize(value.`method`) +
            FfiConverterTypeSessionRequestFfi.allocationSize(value.`params`)
    )

    override fun write(value: SessionRequestJsonRpcFfi, buf: ByteBuffer) {
            FfiConverterULong.write(value.`id`, buf)
            FfiConverterString.write(value.`method`, buf)
            FfiConverterTypeSessionRequestFfi.write(value.`params`, buf)
    }
}



data class SessionRequestJsonRpcResultResponseFfi (
    var `id`: kotlin.ULong, 
    var `jsonrpc`: kotlin.String, 
    var `result`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSessionRequestJsonRpcResultResponseFfi: FfiConverterRustBuffer<SessionRequestJsonRpcResultResponseFfi> {
    override fun read(buf: ByteBuffer): SessionRequestJsonRpcResultResponseFfi {
        return SessionRequestJsonRpcResultResponseFfi(
            FfiConverterULong.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: SessionRequestJsonRpcResultResponseFfi) = (
            FfiConverterULong.allocationSize(value.`id`) +
            FfiConverterString.allocationSize(value.`jsonrpc`) +
            FfiConverterString.allocationSize(value.`result`)
    )

    override fun write(value: SessionRequestJsonRpcResultResponseFfi, buf: ByteBuffer) {
            FfiConverterULong.write(value.`id`, buf)
            FfiConverterString.write(value.`jsonrpc`, buf)
            FfiConverterString.write(value.`result`, buf)
    }
}



data class SessionRequestRequestFfi (
    var `method`: kotlin.String, 
    var `params`: kotlin.String, 
    var `expiry`: kotlin.ULong?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSessionRequestRequestFfi: FfiConverterRustBuffer<SessionRequestRequestFfi> {
    override fun read(buf: ByteBuffer): SessionRequestRequestFfi {
        return SessionRequestRequestFfi(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterOptionalULong.read(buf),
        )
    }

    override fun allocationSize(value: SessionRequestRequestFfi) = (
            FfiConverterString.allocationSize(value.`method`) +
            FfiConverterString.allocationSize(value.`params`) +
            FfiConverterOptionalULong.allocationSize(value.`expiry`)
    )

    override fun write(value: SessionRequestRequestFfi, buf: ByteBuffer) {
            FfiConverterString.write(value.`method`, buf)
            FfiConverterString.write(value.`params`, buf)
            FfiConverterOptionalULong.write(value.`expiry`, buf)
    }
}



data class SettleNamespace (
    var `accounts`: List<kotlin.String>, 
    var `methods`: List<kotlin.String>, 
    var `events`: List<kotlin.String>, 
    var `chains`: List<kotlin.String>
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSettleNamespace: FfiConverterRustBuffer<SettleNamespace> {
    override fun read(buf: ByteBuffer): SettleNamespace {
        return SettleNamespace(
            FfiConverterSequenceString.read(buf),
            FfiConverterSequenceString.read(buf),
            FfiConverterSequenceString.read(buf),
            FfiConverterSequenceString.read(buf),
        )
    }

    override fun allocationSize(value: SettleNamespace) = (
            FfiConverterSequenceString.allocationSize(value.`accounts`) +
            FfiConverterSequenceString.allocationSize(value.`methods`) +
            FfiConverterSequenceString.allocationSize(value.`events`) +
            FfiConverterSequenceString.allocationSize(value.`chains`)
    )

    override fun write(value: SettleNamespace, buf: ByteBuffer) {
            FfiConverterSequenceString.write(value.`accounts`, buf)
            FfiConverterSequenceString.write(value.`methods`, buf)
            FfiConverterSequenceString.write(value.`events`, buf)
            FfiConverterSequenceString.write(value.`chains`, buf)
    }
}



data class SignOutputObject (
    var `toSign`: SignOutputToSign, 
    var `signStep3Params`: SignStep3Params
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSignOutputObject: FfiConverterRustBuffer<SignOutputObject> {
    override fun read(buf: ByteBuffer): SignOutputObject {
        return SignOutputObject(
            FfiConverterTypeSignOutputToSign.read(buf),
            FfiConverterTypeSignStep3Params.read(buf),
        )
    }

    override fun allocationSize(value: SignOutputObject) = (
            FfiConverterTypeSignOutputToSign.allocationSize(value.`toSign`) +
            FfiConverterTypeSignStep3Params.allocationSize(value.`signStep3Params`)
    )

    override fun write(value: SignOutputObject, buf: ByteBuffer) {
            FfiConverterTypeSignOutputToSign.write(value.`toSign`, buf)
            FfiConverterTypeSignStep3Params.write(value.`signStep3Params`, buf)
    }
}



data class SignOutputToSign (
    var `hash`: B256, 
    var `safeOp`: SafeOp, 
    var `domain`: Eip712Domain
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSignOutputToSign: FfiConverterRustBuffer<SignOutputToSign> {
    override fun read(buf: ByteBuffer): SignOutputToSign {
        return SignOutputToSign(
            FfiConverterTypeB256.read(buf),
            FfiConverterTypeSafeOp.read(buf),
            FfiConverterTypeEip712Domain.read(buf),
        )
    }

    override fun allocationSize(value: SignOutputToSign) = (
            FfiConverterTypeB256.allocationSize(value.`hash`) +
            FfiConverterTypeSafeOp.allocationSize(value.`safeOp`) +
            FfiConverterTypeEip712Domain.allocationSize(value.`domain`)
    )

    override fun write(value: SignOutputToSign, buf: ByteBuffer) {
            FfiConverterTypeB256.write(value.`hash`, buf)
            FfiConverterTypeSafeOp.write(value.`safeOp`, buf)
            FfiConverterTypeEip712Domain.write(value.`domain`, buf)
    }
}



data class SignStep3Params (
    var `signature`: Bytes, 
    var `doSendTransactionParams`: DoSendTransactionParams
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSignStep3Params: FfiConverterRustBuffer<SignStep3Params> {
    override fun read(buf: ByteBuffer): SignStep3Params {
        return SignStep3Params(
            FfiConverterTypeBytes.read(buf),
            FfiConverterTypeDoSendTransactionParams.read(buf),
        )
    }

    override fun allocationSize(value: SignStep3Params) = (
            FfiConverterTypeBytes.allocationSize(value.`signature`) +
            FfiConverterTypeDoSendTransactionParams.allocationSize(value.`doSendTransactionParams`)
    )

    override fun write(value: SignStep3Params, buf: ByteBuffer) {
            FfiConverterTypeBytes.write(value.`signature`, buf)
            FfiConverterTypeDoSendTransactionParams.write(value.`doSendTransactionParams`, buf)
    }
}



data class SignTransactionResult (
    var `txBytes`: kotlin.String, 
    var `signature`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSignTransactionResult: FfiConverterRustBuffer<SignTransactionResult> {
    override fun read(buf: ByteBuffer): SignTransactionResult {
        return SignTransactionResult(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: SignTransactionResult) = (
            FfiConverterString.allocationSize(value.`txBytes`) +
            FfiConverterString.allocationSize(value.`signature`)
    )

    override fun write(value: SignTransactionResult, buf: ByteBuffer) {
            FfiConverterString.write(value.`txBytes`, buf)
            FfiConverterString.write(value.`signature`, buf)
    }
}



data class SolanaTransaction (
    var `chainId`: kotlin.String, 
    var `from`: SolanaPubkey, 
    var `transaction`: VersionedTransaction
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSolanaTransaction: FfiConverterRustBuffer<SolanaTransaction> {
    override fun read(buf: ByteBuffer): SolanaTransaction {
        return SolanaTransaction(
            FfiConverterString.read(buf),
            FfiConverterTypeSolanaPubkey.read(buf),
            FfiConverterTypeVersionedTransaction.read(buf),
        )
    }

    override fun allocationSize(value: SolanaTransaction) = (
            FfiConverterString.allocationSize(value.`chainId`) +
            FfiConverterTypeSolanaPubkey.allocationSize(value.`from`) +
            FfiConverterTypeVersionedTransaction.allocationSize(value.`transaction`)
    )

    override fun write(value: SolanaTransaction, buf: ByteBuffer) {
            FfiConverterString.write(value.`chainId`, buf)
            FfiConverterTypeSolanaPubkey.write(value.`from`, buf)
            FfiConverterTypeVersionedTransaction.write(value.`transaction`, buf)
    }
}



data class SolanaTxnDetails (
    var `transaction`: SolanaTransaction, 
    var `transactionHashToSign`: Bytes
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSolanaTxnDetails: FfiConverterRustBuffer<SolanaTxnDetails> {
    override fun read(buf: ByteBuffer): SolanaTxnDetails {
        return SolanaTxnDetails(
            FfiConverterTypeSolanaTransaction.read(buf),
            FfiConverterTypeBytes.read(buf),
        )
    }

    override fun allocationSize(value: SolanaTxnDetails) = (
            FfiConverterTypeSolanaTransaction.allocationSize(value.`transaction`) +
            FfiConverterTypeBytes.allocationSize(value.`transactionHashToSign`)
    )

    override fun write(value: SolanaTxnDetails, buf: ByteBuffer) {
            FfiConverterTypeSolanaTransaction.write(value.`transaction`, buf)
            FfiConverterTypeBytes.write(value.`transactionHashToSign`, buf)
    }
}



data class StacksAccount (
    var `balance`: kotlin.String, 
    var `locked`: kotlin.String, 
    var `unlockHeight`: kotlin.ULong, 
    var `nonce`: kotlin.ULong, 
    var `balanceProof`: kotlin.String, 
    var `nonceProof`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeStacksAccount: FfiConverterRustBuffer<StacksAccount> {
    override fun read(buf: ByteBuffer): StacksAccount {
        return StacksAccount(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: StacksAccount) = (
            FfiConverterString.allocationSize(value.`balance`) +
            FfiConverterString.allocationSize(value.`locked`) +
            FfiConverterULong.allocationSize(value.`unlockHeight`) +
            FfiConverterULong.allocationSize(value.`nonce`) +
            FfiConverterString.allocationSize(value.`balanceProof`) +
            FfiConverterString.allocationSize(value.`nonceProof`)
    )

    override fun write(value: StacksAccount, buf: ByteBuffer) {
            FfiConverterString.write(value.`balance`, buf)
            FfiConverterString.write(value.`locked`, buf)
            FfiConverterULong.write(value.`unlockHeight`, buf)
            FfiConverterULong.write(value.`nonce`, buf)
            FfiConverterString.write(value.`balanceProof`, buf)
            FfiConverterString.write(value.`nonceProof`, buf)
    }
}



data class StatusResponseCompleted (
    var `createdAt`: kotlin.ULong
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeStatusResponseCompleted: FfiConverterRustBuffer<StatusResponseCompleted> {
    override fun read(buf: ByteBuffer): StatusResponseCompleted {
        return StatusResponseCompleted(
            FfiConverterULong.read(buf),
        )
    }

    override fun allocationSize(value: StatusResponseCompleted) = (
            FfiConverterULong.allocationSize(value.`createdAt`)
    )

    override fun write(value: StatusResponseCompleted, buf: ByteBuffer) {
            FfiConverterULong.write(value.`createdAt`, buf)
    }
}



data class StatusResponseError (
    var `createdAt`: kotlin.ULong, 
    var `error`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeStatusResponseError: FfiConverterRustBuffer<StatusResponseError> {
    override fun read(buf: ByteBuffer): StatusResponseError {
        return StatusResponseError(
            FfiConverterULong.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: StatusResponseError) = (
            FfiConverterULong.allocationSize(value.`createdAt`) +
            FfiConverterString.allocationSize(value.`error`)
    )

    override fun write(value: StatusResponseError, buf: ByteBuffer) {
            FfiConverterULong.write(value.`createdAt`, buf)
            FfiConverterString.write(value.`error`, buf)
    }
}



data class StatusResponsePendingObject (
    var `createdAt`: kotlin.ULong, 
    /**
     * Polling interval in ms for the client
     */
    var `checkIn`: kotlin.ULong
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeStatusResponsePendingObject: FfiConverterRustBuffer<StatusResponsePendingObject> {
    override fun read(buf: ByteBuffer): StatusResponsePendingObject {
        return StatusResponsePendingObject(
            FfiConverterULong.read(buf),
            FfiConverterULong.read(buf),
        )
    }

    override fun allocationSize(value: StatusResponsePendingObject) = (
            FfiConverterULong.allocationSize(value.`createdAt`) +
            FfiConverterULong.allocationSize(value.`checkIn`)
    )

    override fun write(value: StatusResponsePendingObject, buf: ByteBuffer) {
            FfiConverterULong.write(value.`createdAt`, buf)
            FfiConverterULong.write(value.`checkIn`, buf)
    }
}



data class Transaction (
    var `chainId`: kotlin.String, 
    var `from`: Address, 
    var `to`: Address, 
    var `value`: U256, 
    var `input`: Bytes, 
    var `gasLimit`: U64, 
    var `nonce`: U64
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeTransaction: FfiConverterRustBuffer<Transaction> {
    override fun read(buf: ByteBuffer): Transaction {
        return Transaction(
            FfiConverterString.read(buf),
            FfiConverterTypeAddress.read(buf),
            FfiConverterTypeAddress.read(buf),
            FfiConverterTypeU256.read(buf),
            FfiConverterTypeBytes.read(buf),
            FfiConverterTypeU64.read(buf),
            FfiConverterTypeU64.read(buf),
        )
    }

    override fun allocationSize(value: Transaction) = (
            FfiConverterString.allocationSize(value.`chainId`) +
            FfiConverterTypeAddress.allocationSize(value.`from`) +
            FfiConverterTypeAddress.allocationSize(value.`to`) +
            FfiConverterTypeU256.allocationSize(value.`value`) +
            FfiConverterTypeBytes.allocationSize(value.`input`) +
            FfiConverterTypeU64.allocationSize(value.`gasLimit`) +
            FfiConverterTypeU64.allocationSize(value.`nonce`)
    )

    override fun write(value: Transaction, buf: ByteBuffer) {
            FfiConverterString.write(value.`chainId`, buf)
            FfiConverterTypeAddress.write(value.`from`, buf)
            FfiConverterTypeAddress.write(value.`to`, buf)
            FfiConverterTypeU256.write(value.`value`, buf)
            FfiConverterTypeBytes.write(value.`input`, buf)
            FfiConverterTypeU64.write(value.`gasLimit`, buf)
            FfiConverterTypeU64.write(value.`nonce`, buf)
    }
}



data class TransactionFee (
    var `fee`: Amount, 
    var `localFee`: Amount
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeTransactionFee: FfiConverterRustBuffer<TransactionFee> {
    override fun read(buf: ByteBuffer): TransactionFee {
        return TransactionFee(
            FfiConverterTypeAmount.read(buf),
            FfiConverterTypeAmount.read(buf),
        )
    }

    override fun allocationSize(value: TransactionFee) = (
            FfiConverterTypeAmount.allocationSize(value.`fee`) +
            FfiConverterTypeAmount.allocationSize(value.`localFee`)
    )

    override fun write(value: TransactionFee, buf: ByteBuffer) {
            FfiConverterTypeAmount.write(value.`fee`, buf)
            FfiConverterTypeAmount.write(value.`localFee`, buf)
    }
}



data class TransferStxRequest (
    var `sender`: kotlin.String, 
    var `amount`: kotlin.ULong, 
    var `recipient`: kotlin.String, 
    var `memo`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeTransferStxRequest: FfiConverterRustBuffer<TransferStxRequest> {
    override fun read(buf: ByteBuffer): TransferStxRequest {
        return TransferStxRequest(
            FfiConverterString.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: TransferStxRequest) = (
            FfiConverterString.allocationSize(value.`sender`) +
            FfiConverterULong.allocationSize(value.`amount`) +
            FfiConverterString.allocationSize(value.`recipient`) +
            FfiConverterString.allocationSize(value.`memo`)
    )

    override fun write(value: TransferStxRequest, buf: ByteBuffer) {
            FfiConverterString.write(value.`sender`, buf)
            FfiConverterULong.write(value.`amount`, buf)
            FfiConverterString.write(value.`recipient`, buf)
            FfiConverterString.write(value.`memo`, buf)
    }
}



data class TransferStxResponse (
    var `txid`: kotlin.String, 
    var `transaction`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeTransferStxResponse: FfiConverterRustBuffer<TransferStxResponse> {
    override fun read(buf: ByteBuffer): TransferStxResponse {
        return TransferStxResponse(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: TransferStxResponse) = (
            FfiConverterString.allocationSize(value.`txid`) +
            FfiConverterString.allocationSize(value.`transaction`)
    )

    override fun write(value: TransferStxResponse, buf: ByteBuffer) {
            FfiConverterString.write(value.`txid`, buf)
            FfiConverterString.write(value.`transaction`, buf)
    }
}



data class TxnDetails (
    var `transaction`: FeeEstimatedTransaction, 
    var `transactionHashToSign`: B256, 
    var `fee`: TransactionFee
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeTxnDetails: FfiConverterRustBuffer<TxnDetails> {
    override fun read(buf: ByteBuffer): TxnDetails {
        return TxnDetails(
            FfiConverterTypeFeeEstimatedTransaction.read(buf),
            FfiConverterTypeB256.read(buf),
            FfiConverterTypeTransactionFee.read(buf),
        )
    }

    override fun allocationSize(value: TxnDetails) = (
            FfiConverterTypeFeeEstimatedTransaction.allocationSize(value.`transaction`) +
            FfiConverterTypeB256.allocationSize(value.`transactionHashToSign`) +
            FfiConverterTypeTransactionFee.allocationSize(value.`fee`)
    )

    override fun write(value: TxnDetails, buf: ByteBuffer) {
            FfiConverterTypeFeeEstimatedTransaction.write(value.`transaction`, buf)
            FfiConverterTypeB256.write(value.`transactionHashToSign`, buf)
            FfiConverterTypeTransactionFee.write(value.`fee`, buf)
    }
}



data class UiFields (
    var `routeResponse`: PrepareResponseAvailable, 
    var `route`: List<Route>, 
    var `localRouteTotal`: Amount, 
    var `bridge`: List<TransactionFee>, 
    var `localBridgeTotal`: Amount, 
    var `initial`: TxnDetails, 
    var `localTotal`: Amount
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeUiFields: FfiConverterRustBuffer<UiFields> {
    override fun read(buf: ByteBuffer): UiFields {
        return UiFields(
            FfiConverterTypePrepareResponseAvailable.read(buf),
            FfiConverterSequenceTypeRoute.read(buf),
            FfiConverterTypeAmount.read(buf),
            FfiConverterSequenceTypeTransactionFee.read(buf),
            FfiConverterTypeAmount.read(buf),
            FfiConverterTypeTxnDetails.read(buf),
            FfiConverterTypeAmount.read(buf),
        )
    }

    override fun allocationSize(value: UiFields) = (
            FfiConverterTypePrepareResponseAvailable.allocationSize(value.`routeResponse`) +
            FfiConverterSequenceTypeRoute.allocationSize(value.`route`) +
            FfiConverterTypeAmount.allocationSize(value.`localRouteTotal`) +
            FfiConverterSequenceTypeTransactionFee.allocationSize(value.`bridge`) +
            FfiConverterTypeAmount.allocationSize(value.`localBridgeTotal`) +
            FfiConverterTypeTxnDetails.allocationSize(value.`initial`) +
            FfiConverterTypeAmount.allocationSize(value.`localTotal`)
    )

    override fun write(value: UiFields, buf: ByteBuffer) {
            FfiConverterTypePrepareResponseAvailable.write(value.`routeResponse`, buf)
            FfiConverterSequenceTypeRoute.write(value.`route`, buf)
            FfiConverterTypeAmount.write(value.`localRouteTotal`, buf)
            FfiConverterSequenceTypeTransactionFee.write(value.`bridge`, buf)
            FfiConverterTypeAmount.write(value.`localBridgeTotal`, buf)
            FfiConverterTypeTxnDetails.write(value.`initial`, buf)
            FfiConverterTypeAmount.write(value.`localTotal`, buf)
    }
}



data class UserOperationV07 (
    var `sender`: AccountAddress, 
    var `nonce`: U256, 
    var `factory`: Address?, 
    var `factoryData`: Bytes?, 
    var `callData`: Bytes, 
    var `callGasLimit`: U256, 
    var `verificationGasLimit`: U256, 
    var `preVerificationGas`: U256, 
    var `maxFeePerGas`: U256, 
    var `maxPriorityFeePerGas`: U256, 
    var `paymaster`: Address?, 
    var `paymasterVerificationGasLimit`: U256?, 
    var `paymasterPostOpGasLimit`: U256?, 
    var `paymasterData`: Bytes?, 
    var `signature`: Bytes
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeUserOperationV07: FfiConverterRustBuffer<UserOperationV07> {
    override fun read(buf: ByteBuffer): UserOperationV07 {
        return UserOperationV07(
            FfiConverterTypeAccountAddress.read(buf),
            FfiConverterTypeU256.read(buf),
            FfiConverterOptionalTypeAddress.read(buf),
            FfiConverterOptionalTypeBytes.read(buf),
            FfiConverterTypeBytes.read(buf),
            FfiConverterTypeU256.read(buf),
            FfiConverterTypeU256.read(buf),
            FfiConverterTypeU256.read(buf),
            FfiConverterTypeU256.read(buf),
            FfiConverterTypeU256.read(buf),
            FfiConverterOptionalTypeAddress.read(buf),
            FfiConverterOptionalTypeU256.read(buf),
            FfiConverterOptionalTypeU256.read(buf),
            FfiConverterOptionalTypeBytes.read(buf),
            FfiConverterTypeBytes.read(buf),
        )
    }

    override fun allocationSize(value: UserOperationV07) = (
            FfiConverterTypeAccountAddress.allocationSize(value.`sender`) +
            FfiConverterTypeU256.allocationSize(value.`nonce`) +
            FfiConverterOptionalTypeAddress.allocationSize(value.`factory`) +
            FfiConverterOptionalTypeBytes.allocationSize(value.`factoryData`) +
            FfiConverterTypeBytes.allocationSize(value.`callData`) +
            FfiConverterTypeU256.allocationSize(value.`callGasLimit`) +
            FfiConverterTypeU256.allocationSize(value.`verificationGasLimit`) +
            FfiConverterTypeU256.allocationSize(value.`preVerificationGas`) +
            FfiConverterTypeU256.allocationSize(value.`maxFeePerGas`) +
            FfiConverterTypeU256.allocationSize(value.`maxPriorityFeePerGas`) +
            FfiConverterOptionalTypeAddress.allocationSize(value.`paymaster`) +
            FfiConverterOptionalTypeU256.allocationSize(value.`paymasterVerificationGasLimit`) +
            FfiConverterOptionalTypeU256.allocationSize(value.`paymasterPostOpGasLimit`) +
            FfiConverterOptionalTypeBytes.allocationSize(value.`paymasterData`) +
            FfiConverterTypeBytes.allocationSize(value.`signature`)
    )

    override fun write(value: UserOperationV07, buf: ByteBuffer) {
            FfiConverterTypeAccountAddress.write(value.`sender`, buf)
            FfiConverterTypeU256.write(value.`nonce`, buf)
            FfiConverterOptionalTypeAddress.write(value.`factory`, buf)
            FfiConverterOptionalTypeBytes.write(value.`factoryData`, buf)
            FfiConverterTypeBytes.write(value.`callData`, buf)
            FfiConverterTypeU256.write(value.`callGasLimit`, buf)
            FfiConverterTypeU256.write(value.`verificationGasLimit`, buf)
            FfiConverterTypeU256.write(value.`preVerificationGas`, buf)
            FfiConverterTypeU256.write(value.`maxFeePerGas`, buf)
            FfiConverterTypeU256.write(value.`maxPriorityFeePerGas`, buf)
            FfiConverterOptionalTypeAddress.write(value.`paymaster`, buf)
            FfiConverterOptionalTypeU256.write(value.`paymasterVerificationGasLimit`, buf)
            FfiConverterOptionalTypeU256.write(value.`paymasterPostOpGasLimit`, buf)
            FfiConverterOptionalTypeBytes.write(value.`paymasterData`, buf)
            FfiConverterTypeBytes.write(value.`signature`, buf)
    }
}



sealed class AddressOrNative {
    
    data class AddressVariant(
        val v1: Address) : AddressOrNative() {
        companion object
    }
    
    object Native : AddressOrNative()
    
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAddressOrNative : FfiConverterRustBuffer<AddressOrNative>{
    override fun read(buf: ByteBuffer): AddressOrNative {
        return when(buf.getInt()) {
            1 -> AddressOrNative.AddressVariant(
                FfiConverterTypeAddress.read(buf),
                )
            2 -> AddressOrNative.Native
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: AddressOrNative) = when(value) {
        is AddressOrNative.AddressVariant -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeAddress.allocationSize(value.v1)
            )
        }
        is AddressOrNative.Native -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: AddressOrNative, buf: ByteBuffer) {
        when(value) {
            is AddressOrNative.AddressVariant -> {
                buf.putInt(1)
                FfiConverterTypeAddress.write(value.v1, buf)
                Unit
            }
            is AddressOrNative.Native -> {
                buf.putInt(2)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







sealed class ApproveException: kotlin.Exception() {
    
    class Request(
        
        val v1: RequestException
        ) : ApproveException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class Internal(
        
        val v1: kotlin.String
        ) : ApproveException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class ShouldNeverHappen(
        
        val v1: kotlin.String
        ) : ApproveException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<ApproveException> {
        override fun lift(error_buf: RustBuffer.ByValue): ApproveException = FfiConverterTypeApproveError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeApproveError : FfiConverterRustBuffer<ApproveException> {
    override fun read(buf: ByteBuffer): ApproveException {
        

        return when(buf.getInt()) {
            1 -> ApproveException.Request(
                FfiConverterTypeRequestError.read(buf),
                )
            2 -> ApproveException.Internal(
                FfiConverterString.read(buf),
                )
            3 -> ApproveException.ShouldNeverHappen(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ApproveException): ULong {
        return when(value) {
            is ApproveException.Request -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeRequestError.allocationSize(value.v1)
            )
            is ApproveException.Internal -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is ApproveException.ShouldNeverHappen -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: ApproveException, buf: ByteBuffer) {
        when(value) {
            is ApproveException.Request -> {
                buf.putInt(1)
                FfiConverterTypeRequestError.write(value.v1, buf)
                Unit
            }
            is ApproveException.Internal -> {
                buf.putInt(2)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is ApproveException.ShouldNeverHappen -> {
                buf.putInt(3)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



sealed class AssetFfi {
    
    data class Native(
        val `address`: AddressOrNative, 
        val `balance`: U256, 
        val `metadata`: NativeMetadata) : AssetFfi() {
        companion object
    }
    
    data class Erc20(
        val `address`: AddressOrNative, 
        val `balance`: U256, 
        val `metadata`: Erc20Metadata) : AssetFfi() {
        companion object
    }
    
    data class Erc721(
        val `address`: AddressOrNative, 
        val `balance`: U256, 
        val `metadata`: Erc721Metadata) : AssetFfi() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAssetFfi : FfiConverterRustBuffer<AssetFfi>{
    override fun read(buf: ByteBuffer): AssetFfi {
        return when(buf.getInt()) {
            1 -> AssetFfi.Native(
                FfiConverterTypeAddressOrNative.read(buf),
                FfiConverterTypeU256.read(buf),
                FfiConverterTypeNativeMetadata.read(buf),
                )
            2 -> AssetFfi.Erc20(
                FfiConverterTypeAddressOrNative.read(buf),
                FfiConverterTypeU256.read(buf),
                FfiConverterTypeErc20Metadata.read(buf),
                )
            3 -> AssetFfi.Erc721(
                FfiConverterTypeAddressOrNative.read(buf),
                FfiConverterTypeU256.read(buf),
                FfiConverterTypeErc721Metadata.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: AssetFfi) = when(value) {
        is AssetFfi.Native -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeAddressOrNative.allocationSize(value.`address`)
                + FfiConverterTypeU256.allocationSize(value.`balance`)
                + FfiConverterTypeNativeMetadata.allocationSize(value.`metadata`)
            )
        }
        is AssetFfi.Erc20 -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeAddressOrNative.allocationSize(value.`address`)
                + FfiConverterTypeU256.allocationSize(value.`balance`)
                + FfiConverterTypeErc20Metadata.allocationSize(value.`metadata`)
            )
        }
        is AssetFfi.Erc721 -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeAddressOrNative.allocationSize(value.`address`)
                + FfiConverterTypeU256.allocationSize(value.`balance`)
                + FfiConverterTypeErc721Metadata.allocationSize(value.`metadata`)
            )
        }
    }

    override fun write(value: AssetFfi, buf: ByteBuffer) {
        when(value) {
            is AssetFfi.Native -> {
                buf.putInt(1)
                FfiConverterTypeAddressOrNative.write(value.`address`, buf)
                FfiConverterTypeU256.write(value.`balance`, buf)
                FfiConverterTypeNativeMetadata.write(value.`metadata`, buf)
                Unit
            }
            is AssetFfi.Erc20 -> {
                buf.putInt(2)
                FfiConverterTypeAddressOrNative.write(value.`address`, buf)
                FfiConverterTypeU256.write(value.`balance`, buf)
                FfiConverterTypeErc20Metadata.write(value.`metadata`, buf)
                Unit
            }
            is AssetFfi.Erc721 -> {
                buf.putInt(3)
                FfiConverterTypeAddressOrNative.write(value.`address`, buf)
                FfiConverterTypeU256.write(value.`balance`, buf)
                FfiConverterTypeErc721Metadata.write(value.`metadata`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class AssetType {
    
    NATIVE,
    ERC20,
    ERC721;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeAssetType: FfiConverterRustBuffer<AssetType> {
    override fun read(buf: ByteBuffer) = try {
        AssetType.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: AssetType) = 4UL

    override fun write(value: AssetType, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class BridgingError {
    
    ASSET_NOT_SUPPORTED,
    NO_ROUTES_AVAILABLE,
    INSUFFICIENT_FUNDS,
    INSUFFICIENT_GAS_FUNDS,
    TRANSACTION_SIMULATION_FAILED,
    UNKNOWN;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeBridgingError: FfiConverterRustBuffer<BridgingError> {
    override fun read(buf: ByteBuffer) = try {
        BridgingError.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: BridgingError) = 4UL

    override fun write(value: BridgingError, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}







sealed class ConnectException: kotlin.Exception() {
    
    class Request(
        
        val v1: RequestException
        ) : ConnectException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class Internal(
        
        val v1: kotlin.String
        ) : ConnectException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class ShouldNeverHappen(
        
        val v1: kotlin.String
        ) : ConnectException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<ConnectException> {
        override fun lift(error_buf: RustBuffer.ByValue): ConnectException = FfiConverterTypeConnectError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeConnectError : FfiConverterRustBuffer<ConnectException> {
    override fun read(buf: ByteBuffer): ConnectException {
        

        return when(buf.getInt()) {
            1 -> ConnectException.Request(
                FfiConverterTypeRequestError.read(buf),
                )
            2 -> ConnectException.Internal(
                FfiConverterString.read(buf),
                )
            3 -> ConnectException.ShouldNeverHappen(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ConnectException): ULong {
        return when(value) {
            is ConnectException.Request -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeRequestError.allocationSize(value.v1)
            )
            is ConnectException.Internal -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is ConnectException.ShouldNeverHappen -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: ConnectException, buf: ByteBuffer) {
        when(value) {
            is ConnectException.Request -> {
                buf.putInt(1)
                FfiConverterTypeRequestError.write(value.v1, buf)
                Unit
            }
            is ConnectException.Internal -> {
                buf.putInt(2)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is ConnectException.ShouldNeverHappen -> {
                buf.putInt(3)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}




enum class Currency {
    
    USD,
    EUR,
    GBP,
    AUD,
    CAD,
    INR,
    JPY,
    BTC,
    ETH;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeCurrency: FfiConverterRustBuffer<Currency> {
    override fun read(buf: ByteBuffer) = try {
        Currency.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: Currency) = 4UL

    override fun write(value: Currency, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}







sealed class DeriveKeypairFromMnemonicException: kotlin.Exception() {
    
    class InvalidMnemonicPhrase(
        
        val v1: kotlin.String
        ) : DeriveKeypairFromMnemonicException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class Derive(
        
        val v1: kotlin.String
        ) : DeriveKeypairFromMnemonicException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<DeriveKeypairFromMnemonicException> {
        override fun lift(error_buf: RustBuffer.ByValue): DeriveKeypairFromMnemonicException = FfiConverterTypeDeriveKeypairFromMnemonicError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeDeriveKeypairFromMnemonicError : FfiConverterRustBuffer<DeriveKeypairFromMnemonicException> {
    override fun read(buf: ByteBuffer): DeriveKeypairFromMnemonicException {
        

        return when(buf.getInt()) {
            1 -> DeriveKeypairFromMnemonicException.InvalidMnemonicPhrase(
                FfiConverterString.read(buf),
                )
            2 -> DeriveKeypairFromMnemonicException.Derive(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: DeriveKeypairFromMnemonicException): ULong {
        return when(value) {
            is DeriveKeypairFromMnemonicException.InvalidMnemonicPhrase -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is DeriveKeypairFromMnemonicException.Derive -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: DeriveKeypairFromMnemonicException, buf: ByteBuffer) {
        when(value) {
            is DeriveKeypairFromMnemonicException.InvalidMnemonicPhrase -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is DeriveKeypairFromMnemonicException.Derive -> {
                buf.putInt(2)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}





sealed class DisconnectException: kotlin.Exception() {
    
    class ShouldNeverHappen(
        
        val v1: kotlin.String
        ) : DisconnectException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class Request(
        
        val v1: RequestException
        ) : DisconnectException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<DisconnectException> {
        override fun lift(error_buf: RustBuffer.ByValue): DisconnectException = FfiConverterTypeDisconnectError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeDisconnectError : FfiConverterRustBuffer<DisconnectException> {
    override fun read(buf: ByteBuffer): DisconnectException {
        

        return when(buf.getInt()) {
            1 -> DisconnectException.ShouldNeverHappen(
                FfiConverterString.read(buf),
                )
            2 -> DisconnectException.Request(
                FfiConverterTypeRequestError.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: DisconnectException): ULong {
        return when(value) {
            is DisconnectException.ShouldNeverHappen -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is DisconnectException.Request -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeRequestError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: DisconnectException, buf: ByteBuffer) {
        when(value) {
            is DisconnectException.ShouldNeverHappen -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is DisconnectException.Request -> {
                buf.putInt(2)
                FfiConverterTypeRequestError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}





sealed class Erc6492Exception: kotlin.Exception() {
    
    class RpcException(
        
        val v1: kotlin.String
        ) : Erc6492Exception() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<Erc6492Exception> {
        override fun lift(error_buf: RustBuffer.ByValue): Erc6492Exception = FfiConverterTypeErc6492Error.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeErc6492Error : FfiConverterRustBuffer<Erc6492Exception> {
    override fun read(buf: ByteBuffer): Erc6492Exception {
        

        return when(buf.getInt()) {
            1 -> Erc6492Exception.RpcException(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: Erc6492Exception): ULong {
        return when(value) {
            is Erc6492Exception.RpcException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: Erc6492Exception, buf: ByteBuffer) {
        when(value) {
            is Erc6492Exception.RpcException -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}





sealed class ExecuteException: kotlin.Exception() {
    
    class WithOrchestrationId(
        
        val `orchestrationId`: kotlin.String, 
        
        val `reason`: ExecuteErrorReason
        ) : ExecuteException() {
        override val message
            get() = "orchestrationId=${ `orchestrationId` }, reason=${ `reason` }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<ExecuteException> {
        override fun lift(error_buf: RustBuffer.ByValue): ExecuteException = FfiConverterTypeExecuteError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeExecuteError : FfiConverterRustBuffer<ExecuteException> {
    override fun read(buf: ByteBuffer): ExecuteException {
        

        return when(buf.getInt()) {
            1 -> ExecuteException.WithOrchestrationId(
                FfiConverterString.read(buf),
                FfiConverterTypeExecuteErrorReason.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ExecuteException): ULong {
        return when(value) {
            is ExecuteException.WithOrchestrationId -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`orchestrationId`)
                + FfiConverterTypeExecuteErrorReason.allocationSize(value.`reason`)
            )
        }
    }

    override fun write(value: ExecuteException, buf: ByteBuffer) {
        when(value) {
            is ExecuteException.WithOrchestrationId -> {
                buf.putInt(1)
                FfiConverterString.write(value.`orchestrationId`, buf)
                FfiConverterTypeExecuteErrorReason.write(value.`reason`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}





sealed class ExecuteErrorReason: kotlin.Exception() {
    
    class Route(
        
        val v1: SendTransactionException
        ) : ExecuteErrorReason() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class Bridge(
        
        val v1: WaitForSuccessException
        ) : ExecuteErrorReason() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class Initial(
        
        val v1: SendTransactionException
        ) : ExecuteErrorReason() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<ExecuteErrorReason> {
        override fun lift(error_buf: RustBuffer.ByValue): ExecuteErrorReason = FfiConverterTypeExecuteErrorReason.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeExecuteErrorReason : FfiConverterRustBuffer<ExecuteErrorReason> {
    override fun read(buf: ByteBuffer): ExecuteErrorReason {
        

        return when(buf.getInt()) {
            1 -> ExecuteErrorReason.Route(
                FfiConverterTypeSendTransactionError.read(buf),
                )
            2 -> ExecuteErrorReason.Bridge(
                FfiConverterTypeWaitForSuccessError.read(buf),
                )
            3 -> ExecuteErrorReason.Initial(
                FfiConverterTypeSendTransactionError.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ExecuteErrorReason): ULong {
        return when(value) {
            is ExecuteErrorReason.Route -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeSendTransactionError.allocationSize(value.v1)
            )
            is ExecuteErrorReason.Bridge -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeWaitForSuccessError.allocationSize(value.v1)
            )
            is ExecuteErrorReason.Initial -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeSendTransactionError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: ExecuteErrorReason, buf: ByteBuffer) {
        when(value) {
            is ExecuteErrorReason.Route -> {
                buf.putInt(1)
                FfiConverterTypeSendTransactionError.write(value.v1, buf)
                Unit
            }
            is ExecuteErrorReason.Bridge -> {
                buf.putInt(2)
                FfiConverterTypeWaitForSuccessError.write(value.v1, buf)
                Unit
            }
            is ExecuteErrorReason.Initial -> {
                buf.putInt(3)
                FfiConverterTypeSendTransactionError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}





sealed class ExtendException: kotlin.Exception() {
    
    class SessionNotFound(
        ) : ExtendException() {
        override val message
            get() = ""
    }
    
    class InvalidExpiry(
        ) : ExtendException() {
        override val message
            get() = ""
    }
    
    class Request(
        
        val v1: RequestException
        ) : ExtendException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class ShouldNeverHappen(
        
        val v1: kotlin.String
        ) : ExtendException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<ExtendException> {
        override fun lift(error_buf: RustBuffer.ByValue): ExtendException = FfiConverterTypeExtendError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeExtendError : FfiConverterRustBuffer<ExtendException> {
    override fun read(buf: ByteBuffer): ExtendException {
        

        return when(buf.getInt()) {
            1 -> ExtendException.SessionNotFound()
            2 -> ExtendException.InvalidExpiry()
            3 -> ExtendException.Request(
                FfiConverterTypeRequestError.read(buf),
                )
            4 -> ExtendException.ShouldNeverHappen(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ExtendException): ULong {
        return when(value) {
            is ExtendException.SessionNotFound -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is ExtendException.InvalidExpiry -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is ExtendException.Request -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeRequestError.allocationSize(value.v1)
            )
            is ExtendException.ShouldNeverHappen -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: ExtendException, buf: ByteBuffer) {
        when(value) {
            is ExtendException.SessionNotFound -> {
                buf.putInt(1)
                Unit
            }
            is ExtendException.InvalidExpiry -> {
                buf.putInt(2)
                Unit
            }
            is ExtendException.Request -> {
                buf.putInt(3)
                FfiConverterTypeRequestError.write(value.v1, buf)
                Unit
            }
            is ExtendException.ShouldNeverHappen -> {
                buf.putInt(4)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}





sealed class NextException: kotlin.Exception() {
    
    class Internal(
        
        val v1: kotlin.String
        ) : NextException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<NextException> {
        override fun lift(error_buf: RustBuffer.ByValue): NextException = FfiConverterTypeNextError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeNextError : FfiConverterRustBuffer<NextException> {
    override fun read(buf: ByteBuffer): NextException {
        

        return when(buf.getInt()) {
            1 -> NextException.Internal(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: NextException): ULong {
        return when(value) {
            is NextException.Internal -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: NextException, buf: ByteBuffer) {
        when(value) {
            is NextException.Internal -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}





sealed class PairException: kotlin.Exception() {
    
    class Request(
        
        val v1: RequestException
        ) : PairException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class Internal(
        
        val v1: kotlin.String
        ) : PairException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class ShouldNeverHappen(
        
        val v1: kotlin.String
        ) : PairException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<PairException> {
        override fun lift(error_buf: RustBuffer.ByValue): PairException = FfiConverterTypePairError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypePairError : FfiConverterRustBuffer<PairException> {
    override fun read(buf: ByteBuffer): PairException {
        

        return when(buf.getInt()) {
            1 -> PairException.Request(
                FfiConverterTypeRequestError.read(buf),
                )
            2 -> PairException.Internal(
                FfiConverterString.read(buf),
                )
            3 -> PairException.ShouldNeverHappen(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: PairException): ULong {
        return when(value) {
            is PairException.Request -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeRequestError.allocationSize(value.v1)
            )
            is PairException.Internal -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is PairException.ShouldNeverHappen -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: PairException, buf: ByteBuffer) {
        when(value) {
            is PairException.Request -> {
                buf.putInt(1)
                FfiConverterTypeRequestError.write(value.v1, buf)
                Unit
            }
            is PairException.Internal -> {
                buf.putInt(2)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is PairException.ShouldNeverHappen -> {
                buf.putInt(3)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



sealed class PrepareDetailedResponse {
    
    data class Success(
        val v1: PrepareDetailedResponseSuccess) : PrepareDetailedResponse() {
        companion object
    }
    
    data class Error(
        val v1: PrepareResponseError) : PrepareDetailedResponse() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePrepareDetailedResponse : FfiConverterRustBuffer<PrepareDetailedResponse>{
    override fun read(buf: ByteBuffer): PrepareDetailedResponse {
        return when(buf.getInt()) {
            1 -> PrepareDetailedResponse.Success(
                FfiConverterTypePrepareDetailedResponseSuccess.read(buf),
                )
            2 -> PrepareDetailedResponse.Error(
                FfiConverterTypePrepareResponseError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: PrepareDetailedResponse) = when(value) {
        is PrepareDetailedResponse.Success -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePrepareDetailedResponseSuccess.allocationSize(value.v1)
            )
        }
        is PrepareDetailedResponse.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePrepareResponseError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: PrepareDetailedResponse, buf: ByteBuffer) {
        when(value) {
            is PrepareDetailedResponse.Success -> {
                buf.putInt(1)
                FfiConverterTypePrepareDetailedResponseSuccess.write(value.v1, buf)
                Unit
            }
            is PrepareDetailedResponse.Error -> {
                buf.putInt(2)
                FfiConverterTypePrepareResponseError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class PrepareDetailedResponseSuccess {
    
    data class Available(
        val v1: UiFields) : PrepareDetailedResponseSuccess() {
        companion object
    }
    
    data class NotRequired(
        val v1: PrepareResponseNotRequired) : PrepareDetailedResponseSuccess() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePrepareDetailedResponseSuccess : FfiConverterRustBuffer<PrepareDetailedResponseSuccess>{
    override fun read(buf: ByteBuffer): PrepareDetailedResponseSuccess {
        return when(buf.getInt()) {
            1 -> PrepareDetailedResponseSuccess.Available(
                FfiConverterTypeUiFields.read(buf),
                )
            2 -> PrepareDetailedResponseSuccess.NotRequired(
                FfiConverterTypePrepareResponseNotRequired.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: PrepareDetailedResponseSuccess) = when(value) {
        is PrepareDetailedResponseSuccess.Available -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUiFields.allocationSize(value.v1)
            )
        }
        is PrepareDetailedResponseSuccess.NotRequired -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePrepareResponseNotRequired.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: PrepareDetailedResponseSuccess, buf: ByteBuffer) {
        when(value) {
            is PrepareDetailedResponseSuccess.Available -> {
                buf.putInt(1)
                FfiConverterTypeUiFields.write(value.v1, buf)
                Unit
            }
            is PrepareDetailedResponseSuccess.NotRequired -> {
                buf.putInt(2)
                FfiConverterTypePrepareResponseNotRequired.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class PrepareResponse {
    
    data class Success(
        val v1: PrepareResponseSuccess) : PrepareResponse() {
        companion object
    }
    
    data class Error(
        val v1: PrepareResponseError) : PrepareResponse() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePrepareResponse : FfiConverterRustBuffer<PrepareResponse>{
    override fun read(buf: ByteBuffer): PrepareResponse {
        return when(buf.getInt()) {
            1 -> PrepareResponse.Success(
                FfiConverterTypePrepareResponseSuccess.read(buf),
                )
            2 -> PrepareResponse.Error(
                FfiConverterTypePrepareResponseError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: PrepareResponse) = when(value) {
        is PrepareResponse.Success -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePrepareResponseSuccess.allocationSize(value.v1)
            )
        }
        is PrepareResponse.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePrepareResponseError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: PrepareResponse, buf: ByteBuffer) {
        when(value) {
            is PrepareResponse.Success -> {
                buf.putInt(1)
                FfiConverterTypePrepareResponseSuccess.write(value.v1, buf)
                Unit
            }
            is PrepareResponse.Error -> {
                buf.putInt(2)
                FfiConverterTypePrepareResponseError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class PrepareResponseSuccess {
    
    data class Available(
        val v1: PrepareResponseAvailable) : PrepareResponseSuccess() {
        companion object
    }
    
    data class NotRequired(
        val v1: PrepareResponseNotRequired) : PrepareResponseSuccess() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePrepareResponseSuccess : FfiConverterRustBuffer<PrepareResponseSuccess>{
    override fun read(buf: ByteBuffer): PrepareResponseSuccess {
        return when(buf.getInt()) {
            1 -> PrepareResponseSuccess.Available(
                FfiConverterTypePrepareResponseAvailable.read(buf),
                )
            2 -> PrepareResponseSuccess.NotRequired(
                FfiConverterTypePrepareResponseNotRequired.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: PrepareResponseSuccess) = when(value) {
        is PrepareResponseSuccess.Available -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePrepareResponseAvailable.allocationSize(value.v1)
            )
        }
        is PrepareResponseSuccess.NotRequired -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePrepareResponseNotRequired.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: PrepareResponseSuccess, buf: ByteBuffer) {
        when(value) {
            is PrepareResponseSuccess.Available -> {
                buf.putInt(1)
                FfiConverterTypePrepareResponseAvailable.write(value.v1, buf)
                Unit
            }
            is PrepareResponseSuccess.NotRequired -> {
                buf.putInt(2)
                FfiConverterTypePrepareResponseNotRequired.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







sealed class RejectException: kotlin.Exception() {
    
    class Request(
        
        val v1: RequestException
        ) : RejectException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class Internal(
        
        val v1: kotlin.String
        ) : RejectException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class ShouldNeverHappen(
        
        val v1: kotlin.String
        ) : RejectException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<RejectException> {
        override fun lift(error_buf: RustBuffer.ByValue): RejectException = FfiConverterTypeRejectError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeRejectError : FfiConverterRustBuffer<RejectException> {
    override fun read(buf: ByteBuffer): RejectException {
        

        return when(buf.getInt()) {
            1 -> RejectException.Request(
                FfiConverterTypeRequestError.read(buf),
                )
            2 -> RejectException.Internal(
                FfiConverterString.read(buf),
                )
            3 -> RejectException.ShouldNeverHappen(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: RejectException): ULong {
        return when(value) {
            is RejectException.Request -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeRequestError.allocationSize(value.v1)
            )
            is RejectException.Internal -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is RejectException.ShouldNeverHappen -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: RejectException, buf: ByteBuffer) {
        when(value) {
            is RejectException.Request -> {
                buf.putInt(1)
                FfiConverterTypeRequestError.write(value.v1, buf)
                Unit
            }
            is RejectException.Internal -> {
                buf.putInt(2)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is RejectException.ShouldNeverHappen -> {
                buf.putInt(3)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}




enum class RejectionReason {
    
    USER_REJECTED,
    UNSUPPORTED_CHAINS,
    UNSUPPORTED_METHODS,
    UNSUPPORTED_ACCOUNTS,
    UNSUPPORTED_EVENTS;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeRejectionReason: FfiConverterRustBuffer<RejectionReason> {
    override fun read(buf: ByteBuffer) = try {
        RejectionReason.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: RejectionReason) = 4UL

    override fun write(value: RejectionReason, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}







sealed class RequestException: kotlin.Exception() {
    
    class Internal(
        
        val v1: kotlin.String
        ) : RequestException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class Offline(
        ) : RequestException() {
        override val message
            get() = ""
    }
    
    class InvalidAuth(
        ) : RequestException() {
        override val message
            get() = ""
    }
    
    /**
     * An error that shouldn't happen (e.g. JSON serializing constant values)
     */
    class ShouldNeverHappen(
        
        val v1: kotlin.String
        ) : RequestException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    /**
     * An error that shouldn't happen because the relay should be behaving as expected
     */
    class ServerMisbehaved(
        
        val v1: kotlin.String
        ) : RequestException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class Cleanup(
        ) : RequestException() {
        override val message
            get() = ""
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<RequestException> {
        override fun lift(error_buf: RustBuffer.ByValue): RequestException = FfiConverterTypeRequestError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeRequestError : FfiConverterRustBuffer<RequestException> {
    override fun read(buf: ByteBuffer): RequestException {
        

        return when(buf.getInt()) {
            1 -> RequestException.Internal(
                FfiConverterString.read(buf),
                )
            2 -> RequestException.Offline()
            3 -> RequestException.InvalidAuth()
            4 -> RequestException.ShouldNeverHappen(
                FfiConverterString.read(buf),
                )
            5 -> RequestException.ServerMisbehaved(
                FfiConverterString.read(buf),
                )
            6 -> RequestException.Cleanup()
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: RequestException): ULong {
        return when(value) {
            is RequestException.Internal -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is RequestException.Offline -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is RequestException.InvalidAuth -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is RequestException.ShouldNeverHappen -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is RequestException.ServerMisbehaved -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is RequestException.Cleanup -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
        }
    }

    override fun write(value: RequestException, buf: ByteBuffer) {
        when(value) {
            is RequestException.Internal -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is RequestException.Offline -> {
                buf.putInt(2)
                Unit
            }
            is RequestException.InvalidAuth -> {
                buf.putInt(3)
                Unit
            }
            is RequestException.ShouldNeverHappen -> {
                buf.putInt(4)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is RequestException.ServerMisbehaved -> {
                buf.putInt(5)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is RequestException.Cleanup -> {
                buf.putInt(6)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}





sealed class RespondException: kotlin.Exception() {
    
    class SessionNotFound(
        ) : RespondException() {
        override val message
            get() = ""
    }
    
    class Request(
        
        val v1: RequestException
        ) : RespondException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class ShouldNeverHappen(
        
        val v1: kotlin.String
        ) : RespondException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<RespondException> {
        override fun lift(error_buf: RustBuffer.ByValue): RespondException = FfiConverterTypeRespondError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeRespondError : FfiConverterRustBuffer<RespondException> {
    override fun read(buf: ByteBuffer): RespondException {
        

        return when(buf.getInt()) {
            1 -> RespondException.SessionNotFound()
            2 -> RespondException.Request(
                FfiConverterTypeRequestError.read(buf),
                )
            3 -> RespondException.ShouldNeverHappen(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: RespondException): ULong {
        return when(value) {
            is RespondException.SessionNotFound -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is RespondException.Request -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeRequestError.allocationSize(value.v1)
            )
            is RespondException.ShouldNeverHappen -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: RespondException, buf: ByteBuffer) {
        when(value) {
            is RespondException.SessionNotFound -> {
                buf.putInt(1)
                Unit
            }
            is RespondException.Request -> {
                buf.putInt(2)
                FfiConverterTypeRequestError.write(value.v1, buf)
                Unit
            }
            is RespondException.ShouldNeverHappen -> {
                buf.putInt(3)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



sealed class Route {
    
    data class Eip155(
        val v1: List<TxnDetails>) : Route() {
        companion object
    }
    
    data class Solana(
        val v1: List<SolanaTxnDetails>) : Route() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeRoute : FfiConverterRustBuffer<Route>{
    override fun read(buf: ByteBuffer): Route {
        return when(buf.getInt()) {
            1 -> Route.Eip155(
                FfiConverterSequenceTypeTxnDetails.read(buf),
                )
            2 -> Route.Solana(
                FfiConverterSequenceTypeSolanaTxnDetails.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: Route) = when(value) {
        is Route.Eip155 -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeTxnDetails.allocationSize(value.v1)
            )
        }
        is Route.Solana -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeSolanaTxnDetails.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: Route, buf: ByteBuffer) {
        when(value) {
            is Route.Eip155 -> {
                buf.putInt(1)
                FfiConverterSequenceTypeTxnDetails.write(value.v1, buf)
                Unit
            }
            is Route.Solana -> {
                buf.putInt(2)
                FfiConverterSequenceTypeSolanaTxnDetails.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class RouteSig {
    
    data class Eip155(
        val v1: List<PrimitiveSignature>) : RouteSig() {
        companion object
    }
    
    data class Solana(
        val v1: List<SolanaSignature>) : RouteSig() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeRouteSig : FfiConverterRustBuffer<RouteSig>{
    override fun read(buf: ByteBuffer): RouteSig {
        return when(buf.getInt()) {
            1 -> RouteSig.Eip155(
                FfiConverterSequenceTypePrimitiveSignature.read(buf),
                )
            2 -> RouteSig.Solana(
                FfiConverterSequenceTypeSolanaSignature.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: RouteSig) = when(value) {
        is RouteSig.Eip155 -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypePrimitiveSignature.allocationSize(value.v1)
            )
        }
        is RouteSig.Solana -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeSolanaSignature.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: RouteSig, buf: ByteBuffer) {
        when(value) {
            is RouteSig.Eip155 -> {
                buf.putInt(1)
                FfiConverterSequenceTypePrimitiveSignature.write(value.v1, buf)
                Unit
            }
            is RouteSig.Solana -> {
                buf.putInt(2)
                FfiConverterSequenceTypeSolanaSignature.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







sealed class SendTransactionException: kotlin.Exception() {
    
    class Rpc(
        
        val v1: RpcError
        ) : SendTransactionException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class PendingTransaction(
        
        val v1: PendingTransactionError
        ) : SendTransactionException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class Failed(
        
        val `txnHash`: B256
        ) : SendTransactionException() {
        override val message
            get() = "txnHash=${ `txnHash` }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<SendTransactionException> {
        override fun lift(error_buf: RustBuffer.ByValue): SendTransactionException = FfiConverterTypeSendTransactionError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeSendTransactionError : FfiConverterRustBuffer<SendTransactionException> {
    override fun read(buf: ByteBuffer): SendTransactionException {
        

        return when(buf.getInt()) {
            1 -> SendTransactionException.Rpc(
                FfiConverterTypeRpcError.read(buf),
                )
            2 -> SendTransactionException.PendingTransaction(
                FfiConverterTypePendingTransactionError.read(buf),
                )
            3 -> SendTransactionException.Failed(
                FfiConverterTypeB256.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SendTransactionException): ULong {
        return when(value) {
            is SendTransactionException.Rpc -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeRpcError.allocationSize(value.v1)
            )
            is SendTransactionException.PendingTransaction -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypePendingTransactionError.allocationSize(value.v1)
            )
            is SendTransactionException.Failed -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeB256.allocationSize(value.`txnHash`)
            )
        }
    }

    override fun write(value: SendTransactionException, buf: ByteBuffer) {
        when(value) {
            is SendTransactionException.Rpc -> {
                buf.putInt(1)
                FfiConverterTypeRpcError.write(value.v1, buf)
                Unit
            }
            is SendTransactionException.PendingTransaction -> {
                buf.putInt(2)
                FfiConverterTypePendingTransactionError.write(value.v1, buf)
                Unit
            }
            is SendTransactionException.Failed -> {
                buf.putInt(3)
                FfiConverterTypeB256.write(value.`txnHash`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



sealed class SessionRequestJsonRpcResponseFfi {
    
    data class Result(
        val v1: SessionRequestJsonRpcResultResponseFfi) : SessionRequestJsonRpcResponseFfi() {
        companion object
    }
    
    data class Error(
        val v1: SessionRequestJsonRpcErrorResponseFfi) : SessionRequestJsonRpcResponseFfi() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSessionRequestJsonRpcResponseFfi : FfiConverterRustBuffer<SessionRequestJsonRpcResponseFfi>{
    override fun read(buf: ByteBuffer): SessionRequestJsonRpcResponseFfi {
        return when(buf.getInt()) {
            1 -> SessionRequestJsonRpcResponseFfi.Result(
                FfiConverterTypeSessionRequestJsonRpcResultResponseFfi.read(buf),
                )
            2 -> SessionRequestJsonRpcResponseFfi.Error(
                FfiConverterTypeSessionRequestJsonRpcErrorResponseFfi.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SessionRequestJsonRpcResponseFfi) = when(value) {
        is SessionRequestJsonRpcResponseFfi.Result -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSessionRequestJsonRpcResultResponseFfi.allocationSize(value.v1)
            )
        }
        is SessionRequestJsonRpcResponseFfi.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSessionRequestJsonRpcErrorResponseFfi.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: SessionRequestJsonRpcResponseFfi, buf: ByteBuffer) {
        when(value) {
            is SessionRequestJsonRpcResponseFfi.Result -> {
                buf.putInt(1)
                FfiConverterTypeSessionRequestJsonRpcResultResponseFfi.write(value.v1, buf)
                Unit
            }
            is SessionRequestJsonRpcResponseFfi.Error -> {
                buf.putInt(2)
                FfiConverterTypeSessionRequestJsonRpcErrorResponseFfi.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class SignOutputEnum {
    
    data class Signature(
        val v1: Bytes) : SignOutputEnum() {
        companion object
    }
    
    data class SignOutput(
        val v1: SignOutputObject) : SignOutputEnum() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSignOutputEnum : FfiConverterRustBuffer<SignOutputEnum>{
    override fun read(buf: ByteBuffer): SignOutputEnum {
        return when(buf.getInt()) {
            1 -> SignOutputEnum.Signature(
                FfiConverterTypeBytes.read(buf),
                )
            2 -> SignOutputEnum.SignOutput(
                FfiConverterTypeSignOutputObject.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SignOutputEnum) = when(value) {
        is SignOutputEnum.Signature -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeBytes.allocationSize(value.v1)
            )
        }
        is SignOutputEnum.SignOutput -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSignOutputObject.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: SignOutputEnum, buf: ByteBuffer) {
        when(value) {
            is SignOutputEnum.Signature -> {
                buf.putInt(1)
                FfiConverterTypeBytes.write(value.v1, buf)
                Unit
            }
            is SignOutputEnum.SignOutput -> {
                buf.putInt(2)
                FfiConverterTypeSignOutputObject.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







sealed class SolanaDeriveKeypairFromMnemonicException: kotlin.Exception() {
    
    class DerivationPath(
        
        val v1: kotlin.String
        ) : SolanaDeriveKeypairFromMnemonicException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class Derive(
        
        val v1: kotlin.String
        ) : SolanaDeriveKeypairFromMnemonicException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<SolanaDeriveKeypairFromMnemonicException> {
        override fun lift(error_buf: RustBuffer.ByValue): SolanaDeriveKeypairFromMnemonicException = FfiConverterTypeSolanaDeriveKeypairFromMnemonicError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeSolanaDeriveKeypairFromMnemonicError : FfiConverterRustBuffer<SolanaDeriveKeypairFromMnemonicException> {
    override fun read(buf: ByteBuffer): SolanaDeriveKeypairFromMnemonicException {
        

        return when(buf.getInt()) {
            1 -> SolanaDeriveKeypairFromMnemonicException.DerivationPath(
                FfiConverterString.read(buf),
                )
            2 -> SolanaDeriveKeypairFromMnemonicException.Derive(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SolanaDeriveKeypairFromMnemonicException): ULong {
        return when(value) {
            is SolanaDeriveKeypairFromMnemonicException.DerivationPath -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is SolanaDeriveKeypairFromMnemonicException.Derive -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: SolanaDeriveKeypairFromMnemonicException, buf: ByteBuffer) {
        when(value) {
            is SolanaDeriveKeypairFromMnemonicException.DerivationPath -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is SolanaDeriveKeypairFromMnemonicException.Derive -> {
                buf.putInt(2)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}





sealed class StacksAccountException: kotlin.Exception() {
    
    class FetchAccount(
        
        val v1: kotlin.String
        ) : StacksAccountException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<StacksAccountException> {
        override fun lift(error_buf: RustBuffer.ByValue): StacksAccountException = FfiConverterTypeStacksAccountError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeStacksAccountError : FfiConverterRustBuffer<StacksAccountException> {
    override fun read(buf: ByteBuffer): StacksAccountException {
        

        return when(buf.getInt()) {
            1 -> StacksAccountException.FetchAccount(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: StacksAccountException): ULong {
        return when(value) {
            is StacksAccountException.FetchAccount -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: StacksAccountException, buf: ByteBuffer) {
        when(value) {
            is StacksAccountException.FetchAccount -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}





sealed class StacksFeesException: kotlin.Exception() {
    
    class TransferFees(
        
        val v1: kotlin.String
        ) : StacksFeesException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class InvalidResponse(
        
        val v1: kotlin.String
        ) : StacksFeesException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<StacksFeesException> {
        override fun lift(error_buf: RustBuffer.ByValue): StacksFeesException = FfiConverterTypeStacksFeesError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeStacksFeesError : FfiConverterRustBuffer<StacksFeesException> {
    override fun read(buf: ByteBuffer): StacksFeesException {
        

        return when(buf.getInt()) {
            1 -> StacksFeesException.TransferFees(
                FfiConverterString.read(buf),
                )
            2 -> StacksFeesException.InvalidResponse(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: StacksFeesException): ULong {
        return when(value) {
            is StacksFeesException.TransferFees -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is StacksFeesException.InvalidResponse -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: StacksFeesException, buf: ByteBuffer) {
        when(value) {
            is StacksFeesException.TransferFees -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is StacksFeesException.InvalidResponse -> {
                buf.putInt(2)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}





sealed class StacksGetAddressException: kotlin.Exception() {
    
    class InvalidSecretKey(
        
        val v1: StacksWalletError
        ) : StacksGetAddressException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class GetAccount(
        
        val v1: StacksWalletError
        ) : StacksGetAddressException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class GetAddress(
        
        val v1: StacksWalletError
        ) : StacksGetAddressException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class InvalidVersion(
        
        val v1: kotlin.String
        ) : StacksGetAddressException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<StacksGetAddressException> {
        override fun lift(error_buf: RustBuffer.ByValue): StacksGetAddressException = FfiConverterTypeStacksGetAddressError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeStacksGetAddressError : FfiConverterRustBuffer<StacksGetAddressException> {
    override fun read(buf: ByteBuffer): StacksGetAddressException {
        

        return when(buf.getInt()) {
            1 -> StacksGetAddressException.InvalidSecretKey(
                FfiConverterTypeStacksWalletError.read(buf),
                )
            2 -> StacksGetAddressException.GetAccount(
                FfiConverterTypeStacksWalletError.read(buf),
                )
            3 -> StacksGetAddressException.GetAddress(
                FfiConverterTypeStacksWalletError.read(buf),
                )
            4 -> StacksGetAddressException.InvalidVersion(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: StacksGetAddressException): ULong {
        return when(value) {
            is StacksGetAddressException.InvalidSecretKey -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeStacksWalletError.allocationSize(value.v1)
            )
            is StacksGetAddressException.GetAccount -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeStacksWalletError.allocationSize(value.v1)
            )
            is StacksGetAddressException.GetAddress -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeStacksWalletError.allocationSize(value.v1)
            )
            is StacksGetAddressException.InvalidVersion -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: StacksGetAddressException, buf: ByteBuffer) {
        when(value) {
            is StacksGetAddressException.InvalidSecretKey -> {
                buf.putInt(1)
                FfiConverterTypeStacksWalletError.write(value.v1, buf)
                Unit
            }
            is StacksGetAddressException.GetAccount -> {
                buf.putInt(2)
                FfiConverterTypeStacksWalletError.write(value.v1, buf)
                Unit
            }
            is StacksGetAddressException.GetAddress -> {
                buf.putInt(3)
                FfiConverterTypeStacksWalletError.write(value.v1, buf)
                Unit
            }
            is StacksGetAddressException.InvalidVersion -> {
                buf.putInt(4)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}





sealed class StacksSignMessageException: kotlin.Exception() {
    
    class InvalidSecretKey(
        
        val v1: StacksWalletError
        ) : StacksSignMessageException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class GetAccount(
        
        val v1: StacksWalletError
        ) : StacksSignMessageException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class UnwrapPrivateKey(
        
        val v1: StacksWalletError
        ) : StacksSignMessageException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<StacksSignMessageException> {
        override fun lift(error_buf: RustBuffer.ByValue): StacksSignMessageException = FfiConverterTypeStacksSignMessageError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeStacksSignMessageError : FfiConverterRustBuffer<StacksSignMessageException> {
    override fun read(buf: ByteBuffer): StacksSignMessageException {
        

        return when(buf.getInt()) {
            1 -> StacksSignMessageException.InvalidSecretKey(
                FfiConverterTypeStacksWalletError.read(buf),
                )
            2 -> StacksSignMessageException.GetAccount(
                FfiConverterTypeStacksWalletError.read(buf),
                )
            3 -> StacksSignMessageException.UnwrapPrivateKey(
                FfiConverterTypeStacksWalletError.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: StacksSignMessageException): ULong {
        return when(value) {
            is StacksSignMessageException.InvalidSecretKey -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeStacksWalletError.allocationSize(value.v1)
            )
            is StacksSignMessageException.GetAccount -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeStacksWalletError.allocationSize(value.v1)
            )
            is StacksSignMessageException.UnwrapPrivateKey -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeStacksWalletError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: StacksSignMessageException, buf: ByteBuffer) {
        when(value) {
            is StacksSignMessageException.InvalidSecretKey -> {
                buf.putInt(1)
                FfiConverterTypeStacksWalletError.write(value.v1, buf)
                Unit
            }
            is StacksSignMessageException.GetAccount -> {
                buf.putInt(2)
                FfiConverterTypeStacksWalletError.write(value.v1, buf)
                Unit
            }
            is StacksSignMessageException.UnwrapPrivateKey -> {
                buf.putInt(3)
                FfiConverterTypeStacksWalletError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}





sealed class StacksSignTransactionException: kotlin.Exception() {
    
    class InvalidSecretKey(
        
        val v1: StacksWalletError
        ) : StacksSignTransactionException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class UnwrapPrivateKey(
        
        val v1: StacksWalletError
        ) : StacksSignTransactionException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class InvalidNetwork(
        
        val v1: kotlin.String
        ) : StacksSignTransactionException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class SignTransaction(
        
        val v1: StacksTransactionError
        ) : StacksSignTransactionException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class Hash(
        
        val v1: StacksTransactionError
        ) : StacksSignTransactionException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class Encode(
        
        val v1: ClarityError
        ) : StacksSignTransactionException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class MemoTooLong(
        
        val v1: kotlin.UInt
        ) : StacksSignTransactionException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<StacksSignTransactionException> {
        override fun lift(error_buf: RustBuffer.ByValue): StacksSignTransactionException = FfiConverterTypeStacksSignTransactionError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeStacksSignTransactionError : FfiConverterRustBuffer<StacksSignTransactionException> {
    override fun read(buf: ByteBuffer): StacksSignTransactionException {
        

        return when(buf.getInt()) {
            1 -> StacksSignTransactionException.InvalidSecretKey(
                FfiConverterTypeStacksWalletError.read(buf),
                )
            2 -> StacksSignTransactionException.UnwrapPrivateKey(
                FfiConverterTypeStacksWalletError.read(buf),
                )
            3 -> StacksSignTransactionException.InvalidNetwork(
                FfiConverterString.read(buf),
                )
            4 -> StacksSignTransactionException.SignTransaction(
                FfiConverterTypeStacksTransactionError.read(buf),
                )
            5 -> StacksSignTransactionException.Hash(
                FfiConverterTypeStacksTransactionError.read(buf),
                )
            6 -> StacksSignTransactionException.Encode(
                FfiConverterTypeClarityError.read(buf),
                )
            7 -> StacksSignTransactionException.MemoTooLong(
                FfiConverterUInt.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: StacksSignTransactionException): ULong {
        return when(value) {
            is StacksSignTransactionException.InvalidSecretKey -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeStacksWalletError.allocationSize(value.v1)
            )
            is StacksSignTransactionException.UnwrapPrivateKey -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeStacksWalletError.allocationSize(value.v1)
            )
            is StacksSignTransactionException.InvalidNetwork -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is StacksSignTransactionException.SignTransaction -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeStacksTransactionError.allocationSize(value.v1)
            )
            is StacksSignTransactionException.Hash -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeStacksTransactionError.allocationSize(value.v1)
            )
            is StacksSignTransactionException.Encode -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeClarityError.allocationSize(value.v1)
            )
            is StacksSignTransactionException.MemoTooLong -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterUInt.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: StacksSignTransactionException, buf: ByteBuffer) {
        when(value) {
            is StacksSignTransactionException.InvalidSecretKey -> {
                buf.putInt(1)
                FfiConverterTypeStacksWalletError.write(value.v1, buf)
                Unit
            }
            is StacksSignTransactionException.UnwrapPrivateKey -> {
                buf.putInt(2)
                FfiConverterTypeStacksWalletError.write(value.v1, buf)
                Unit
            }
            is StacksSignTransactionException.InvalidNetwork -> {
                buf.putInt(3)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is StacksSignTransactionException.SignTransaction -> {
                buf.putInt(4)
                FfiConverterTypeStacksTransactionError.write(value.v1, buf)
                Unit
            }
            is StacksSignTransactionException.Hash -> {
                buf.putInt(5)
                FfiConverterTypeStacksTransactionError.write(value.v1, buf)
                Unit
            }
            is StacksSignTransactionException.Encode -> {
                buf.putInt(6)
                FfiConverterTypeClarityError.write(value.v1, buf)
                Unit
            }
            is StacksSignTransactionException.MemoTooLong -> {
                buf.putInt(7)
                FfiConverterUInt.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}





sealed class StacksTransferStxException: kotlin.Exception() {
    
    class SignTransaction(
        
        val v1: StacksSignTransactionException
        ) : StacksTransferStxException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class BroadcastTransaction(
        
        val v1: kotlin.String
        ) : StacksTransferStxException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class FetchAccount(
        
        val v1: kotlin.String
        ) : StacksTransferStxException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class TransferFees(
        
        val v1: kotlin.String
        ) : StacksTransferStxException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<StacksTransferStxException> {
        override fun lift(error_buf: RustBuffer.ByValue): StacksTransferStxException = FfiConverterTypeStacksTransferStxError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeStacksTransferStxError : FfiConverterRustBuffer<StacksTransferStxException> {
    override fun read(buf: ByteBuffer): StacksTransferStxException {
        

        return when(buf.getInt()) {
            1 -> StacksTransferStxException.SignTransaction(
                FfiConverterTypeStacksSignTransactionError.read(buf),
                )
            2 -> StacksTransferStxException.BroadcastTransaction(
                FfiConverterString.read(buf),
                )
            3 -> StacksTransferStxException.FetchAccount(
                FfiConverterString.read(buf),
                )
            4 -> StacksTransferStxException.TransferFees(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: StacksTransferStxException): ULong {
        return when(value) {
            is StacksTransferStxException.SignTransaction -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeStacksSignTransactionError.allocationSize(value.v1)
            )
            is StacksTransferStxException.BroadcastTransaction -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is StacksTransferStxException.FetchAccount -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is StacksTransferStxException.TransferFees -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: StacksTransferStxException, buf: ByteBuffer) {
        when(value) {
            is StacksTransferStxException.SignTransaction -> {
                buf.putInt(1)
                FfiConverterTypeStacksSignTransactionError.write(value.v1, buf)
                Unit
            }
            is StacksTransferStxException.BroadcastTransaction -> {
                buf.putInt(2)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is StacksTransferStxException.FetchAccount -> {
                buf.putInt(3)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is StacksTransferStxException.TransferFees -> {
                buf.putInt(4)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}





sealed class StatusException: kotlin.Exception() {
    
    /**
     * Retryable error
     */
    class Request(
        
        val v1: ReqwestError
        ) : StatusException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    /**
     * Retryable error
     */
    class RequestFailed(
        
        val v1: StatusCode, 
        
        val v2: kotlin.String
        ) : StatusException() {
        override val message
            get() = "v1=${ v1 }, v2=${ v2 }"
    }
    
    /**
     * Retryable error
     */
    class RequestFailedText(
        
        val v1: StatusCode, 
        
        val v2: ReqwestError
        ) : StatusException() {
        override val message
            get() = "v1=${ v1 }, v2=${ v2 }"
    }
    
    /**
     * Retryable error
     */
    class DecodingText(
        
        val v1: StatusCode, 
        
        val v2: ReqwestError
        ) : StatusException() {
        override val message
            get() = "v1=${ v1 }, v2=${ v2 }"
    }
    
    /**
     * Retryable error
     */
    class DecodingJson(
        
        val v1: StatusCode, 
        
        val v2: SerdeJsonError, 
        
        val v3: kotlin.String
        ) : StatusException() {
        override val message
            get() = "v1=${ v1 }, v2=${ v2 }, v3=${ v3 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<StatusException> {
        override fun lift(error_buf: RustBuffer.ByValue): StatusException = FfiConverterTypeStatusError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeStatusError : FfiConverterRustBuffer<StatusException> {
    override fun read(buf: ByteBuffer): StatusException {
        

        return when(buf.getInt()) {
            1 -> StatusException.Request(
                FfiConverterTypeReqwestError.read(buf),
                )
            2 -> StatusException.RequestFailed(
                FfiConverterTypeStatusCode.read(buf),
                FfiConverterString.read(buf),
                )
            3 -> StatusException.RequestFailedText(
                FfiConverterTypeStatusCode.read(buf),
                FfiConverterTypeReqwestError.read(buf),
                )
            4 -> StatusException.DecodingText(
                FfiConverterTypeStatusCode.read(buf),
                FfiConverterTypeReqwestError.read(buf),
                )
            5 -> StatusException.DecodingJson(
                FfiConverterTypeStatusCode.read(buf),
                FfiConverterTypeSerdeJsonError.read(buf),
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: StatusException): ULong {
        return when(value) {
            is StatusException.Request -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeReqwestError.allocationSize(value.v1)
            )
            is StatusException.RequestFailed -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeStatusCode.allocationSize(value.v1)
                + FfiConverterString.allocationSize(value.v2)
            )
            is StatusException.RequestFailedText -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeStatusCode.allocationSize(value.v1)
                + FfiConverterTypeReqwestError.allocationSize(value.v2)
            )
            is StatusException.DecodingText -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeStatusCode.allocationSize(value.v1)
                + FfiConverterTypeReqwestError.allocationSize(value.v2)
            )
            is StatusException.DecodingJson -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeStatusCode.allocationSize(value.v1)
                + FfiConverterTypeSerdeJsonError.allocationSize(value.v2)
                + FfiConverterString.allocationSize(value.v3)
            )
        }
    }

    override fun write(value: StatusException, buf: ByteBuffer) {
        when(value) {
            is StatusException.Request -> {
                buf.putInt(1)
                FfiConverterTypeReqwestError.write(value.v1, buf)
                Unit
            }
            is StatusException.RequestFailed -> {
                buf.putInt(2)
                FfiConverterTypeStatusCode.write(value.v1, buf)
                FfiConverterString.write(value.v2, buf)
                Unit
            }
            is StatusException.RequestFailedText -> {
                buf.putInt(3)
                FfiConverterTypeStatusCode.write(value.v1, buf)
                FfiConverterTypeReqwestError.write(value.v2, buf)
                Unit
            }
            is StatusException.DecodingText -> {
                buf.putInt(4)
                FfiConverterTypeStatusCode.write(value.v1, buf)
                FfiConverterTypeReqwestError.write(value.v2, buf)
                Unit
            }
            is StatusException.DecodingJson -> {
                buf.putInt(5)
                FfiConverterTypeStatusCode.write(value.v1, buf)
                FfiConverterTypeSerdeJsonError.write(value.v2, buf)
                FfiConverterString.write(value.v3, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



sealed class StatusResponse {
    
    data class Pending(
        val v1: StatusResponsePendingObject) : StatusResponse() {
        companion object
    }
    
    data class Completed(
        val v1: StatusResponseCompleted) : StatusResponse() {
        companion object
    }
    
    data class Error(
        val v1: StatusResponseError) : StatusResponse() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeStatusResponse : FfiConverterRustBuffer<StatusResponse>{
    override fun read(buf: ByteBuffer): StatusResponse {
        return when(buf.getInt()) {
            1 -> StatusResponse.Pending(
                FfiConverterTypeStatusResponsePendingObject.read(buf),
                )
            2 -> StatusResponse.Completed(
                FfiConverterTypeStatusResponseCompleted.read(buf),
                )
            3 -> StatusResponse.Error(
                FfiConverterTypeStatusResponseError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: StatusResponse) = when(value) {
        is StatusResponse.Pending -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeStatusResponsePendingObject.allocationSize(value.v1)
            )
        }
        is StatusResponse.Completed -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeStatusResponseCompleted.allocationSize(value.v1)
            )
        }
        is StatusResponse.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeStatusResponseError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: StatusResponse, buf: ByteBuffer) {
        when(value) {
            is StatusResponse.Pending -> {
                buf.putInt(1)
                FfiConverterTypeStatusResponsePendingObject.write(value.v1, buf)
                Unit
            }
            is StatusResponse.Completed -> {
                buf.putInt(2)
                FfiConverterTypeStatusResponseCompleted.write(value.v1, buf)
                Unit
            }
            is StatusResponse.Error -> {
                buf.putInt(3)
                FfiConverterTypeStatusResponseError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







sealed class SuiException: kotlin.Exception() {
    
    class SignTransaction(
        
        val v1: SuiSignTransactionException
        ) : SuiException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class GetAllBalances(
        
        val v1: SuiSdkError
        ) : SuiException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class ExecuteTransactionBlock(
        
        val v1: SuiSdkError
        ) : SuiException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<SuiException> {
        override fun lift(error_buf: RustBuffer.ByValue): SuiException = FfiConverterTypeSuiError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeSuiError : FfiConverterRustBuffer<SuiException> {
    override fun read(buf: ByteBuffer): SuiException {
        

        return when(buf.getInt()) {
            1 -> SuiException.SignTransaction(
                FfiConverterTypeSuiSignTransactionError.read(buf),
                )
            2 -> SuiException.GetAllBalances(
                FfiConverterTypeSuiSdkError.read(buf),
                )
            3 -> SuiException.ExecuteTransactionBlock(
                FfiConverterTypeSuiSdkError.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SuiException): ULong {
        return when(value) {
            is SuiException.SignTransaction -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeSuiSignTransactionError.allocationSize(value.v1)
            )
            is SuiException.GetAllBalances -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeSuiSdkError.allocationSize(value.v1)
            )
            is SuiException.ExecuteTransactionBlock -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeSuiSdkError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: SuiException, buf: ByteBuffer) {
        when(value) {
            is SuiException.SignTransaction -> {
                buf.putInt(1)
                FfiConverterTypeSuiSignTransactionError.write(value.v1, buf)
                Unit
            }
            is SuiException.GetAllBalances -> {
                buf.putInt(2)
                FfiConverterTypeSuiSdkError.write(value.v1, buf)
                Unit
            }
            is SuiException.ExecuteTransactionBlock -> {
                buf.putInt(3)
                FfiConverterTypeSuiSdkError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}





sealed class SuiSignTransactionException: kotlin.Exception() {
    
    class InvalidTransactionData(
        
        val v1: kotlin.String
        ) : SuiSignTransactionException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class MisMatchedSenderAddress(
        
        val v1: SuiAddress, 
        
        val v2: SuiAddress
        ) : SuiSignTransactionException() {
        override val message
            get() = "v1=${ v1 }, v2=${ v2 }"
    }
    
    class GetReferenceGasPrice(
        
        val v1: SuiSdkError
        ) : SuiSignTransactionException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class GetCoinsForGas(
        
        val v1: SuiSdkError
        ) : SuiSignTransactionException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class NoCoinsAvailableForGas(
        
        val v1: SuiAddress
        ) : SuiSignTransactionException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<SuiSignTransactionException> {
        override fun lift(error_buf: RustBuffer.ByValue): SuiSignTransactionException = FfiConverterTypeSuiSignTransactionError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeSuiSignTransactionError : FfiConverterRustBuffer<SuiSignTransactionException> {
    override fun read(buf: ByteBuffer): SuiSignTransactionException {
        

        return when(buf.getInt()) {
            1 -> SuiSignTransactionException.InvalidTransactionData(
                FfiConverterString.read(buf),
                )
            2 -> SuiSignTransactionException.MisMatchedSenderAddress(
                FfiConverterTypeSuiAddress.read(buf),
                FfiConverterTypeSuiAddress.read(buf),
                )
            3 -> SuiSignTransactionException.GetReferenceGasPrice(
                FfiConverterTypeSuiSdkError.read(buf),
                )
            4 -> SuiSignTransactionException.GetCoinsForGas(
                FfiConverterTypeSuiSdkError.read(buf),
                )
            5 -> SuiSignTransactionException.NoCoinsAvailableForGas(
                FfiConverterTypeSuiAddress.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SuiSignTransactionException): ULong {
        return when(value) {
            is SuiSignTransactionException.InvalidTransactionData -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is SuiSignTransactionException.MisMatchedSenderAddress -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeSuiAddress.allocationSize(value.v1)
                + FfiConverterTypeSuiAddress.allocationSize(value.v2)
            )
            is SuiSignTransactionException.GetReferenceGasPrice -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeSuiSdkError.allocationSize(value.v1)
            )
            is SuiSignTransactionException.GetCoinsForGas -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeSuiSdkError.allocationSize(value.v1)
            )
            is SuiSignTransactionException.NoCoinsAvailableForGas -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeSuiAddress.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: SuiSignTransactionException, buf: ByteBuffer) {
        when(value) {
            is SuiSignTransactionException.InvalidTransactionData -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is SuiSignTransactionException.MisMatchedSenderAddress -> {
                buf.putInt(2)
                FfiConverterTypeSuiAddress.write(value.v1, buf)
                FfiConverterTypeSuiAddress.write(value.v2, buf)
                Unit
            }
            is SuiSignTransactionException.GetReferenceGasPrice -> {
                buf.putInt(3)
                FfiConverterTypeSuiSdkError.write(value.v1, buf)
                Unit
            }
            is SuiSignTransactionException.GetCoinsForGas -> {
                buf.putInt(4)
                FfiConverterTypeSuiSdkError.write(value.v1, buf)
                Unit
            }
            is SuiSignTransactionException.NoCoinsAvailableForGas -> {
                buf.putInt(5)
                FfiConverterTypeSuiAddress.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



sealed class Transactions {
    
    data class Eip155(
        val v1: List<Transaction>) : Transactions() {
        companion object
    }
    
    data class Solana(
        val v1: List<SolanaTransaction>) : Transactions() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeTransactions : FfiConverterRustBuffer<Transactions>{
    override fun read(buf: ByteBuffer): Transactions {
        return when(buf.getInt()) {
            1 -> Transactions.Eip155(
                FfiConverterSequenceTypeTransaction.read(buf),
                )
            2 -> Transactions.Solana(
                FfiConverterSequenceTypeSolanaTransaction.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: Transactions) = when(value) {
        is Transactions.Eip155 -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeTransaction.allocationSize(value.v1)
            )
        }
        is Transactions.Solana -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeSolanaTransaction.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: Transactions, buf: ByteBuffer) {
        when(value) {
            is Transactions.Eip155 -> {
                buf.putInt(1)
                FfiConverterSequenceTypeTransaction.write(value.v1, buf)
                Unit
            }
            is Transactions.Solana -> {
                buf.putInt(2)
                FfiConverterSequenceTypeSolanaTransaction.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







sealed class TransferFeesException: kotlin.Exception() {
    
    class FeeRate(
        
        val v1: kotlin.String
        ) : TransferFeesException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<TransferFeesException> {
        override fun lift(error_buf: RustBuffer.ByValue): TransferFeesException = FfiConverterTypeTransferFeesError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeTransferFeesError : FfiConverterRustBuffer<TransferFeesException> {
    override fun read(buf: ByteBuffer): TransferFeesException {
        

        return when(buf.getInt()) {
            1 -> TransferFeesException.FeeRate(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: TransferFeesException): ULong {
        return when(value) {
            is TransferFeesException.FeeRate -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: TransferFeesException, buf: ByteBuffer) {
        when(value) {
            is TransferFeesException.FeeRate -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}




enum class TransportType {
    
    RELAY,
    LINK_MODE;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeTransportType: FfiConverterRustBuffer<TransportType> {
    override fun read(buf: ByteBuffer) = try {
        TransportType.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: TransportType) = 4UL

    override fun write(value: TransportType, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}







sealed class UpdateException: kotlin.Exception() {
    
    class SessionNotFound(
        ) : UpdateException() {
        override val message
            get() = ""
    }
    
    class Unauthorized(
        ) : UpdateException() {
        override val message
            get() = ""
    }
    
    class Request(
        
        val v1: RequestException
        ) : UpdateException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class Internal(
        
        val v1: kotlin.String
        ) : UpdateException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class ShouldNeverHappen(
        
        val v1: kotlin.String
        ) : UpdateException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<UpdateException> {
        override fun lift(error_buf: RustBuffer.ByValue): UpdateException = FfiConverterTypeUpdateError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeUpdateError : FfiConverterRustBuffer<UpdateException> {
    override fun read(buf: ByteBuffer): UpdateException {
        

        return when(buf.getInt()) {
            1 -> UpdateException.SessionNotFound()
            2 -> UpdateException.Unauthorized()
            3 -> UpdateException.Request(
                FfiConverterTypeRequestError.read(buf),
                )
            4 -> UpdateException.Internal(
                FfiConverterString.read(buf),
                )
            5 -> UpdateException.ShouldNeverHappen(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: UpdateException): ULong {
        return when(value) {
            is UpdateException.SessionNotFound -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is UpdateException.Unauthorized -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is UpdateException.Request -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeRequestError.allocationSize(value.v1)
            )
            is UpdateException.Internal -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is UpdateException.ShouldNeverHappen -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: UpdateException, buf: ByteBuffer) {
        when(value) {
            is UpdateException.SessionNotFound -> {
                buf.putInt(1)
                Unit
            }
            is UpdateException.Unauthorized -> {
                buf.putInt(2)
                Unit
            }
            is UpdateException.Request -> {
                buf.putInt(3)
                FfiConverterTypeRequestError.write(value.v1, buf)
                Unit
            }
            is UpdateException.Internal -> {
                buf.putInt(4)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is UpdateException.ShouldNeverHappen -> {
                buf.putInt(5)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}





sealed class WaitForSuccessException: kotlin.Exception() {
    
    class Status(
        
        val v1: StatusException
        ) : WaitForSuccessException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class StatusResponseException(
        
        val v1: StatusResponseError
        ) : WaitForSuccessException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class StatusResponsePending(
        
        val v1: StatusResponsePendingObject
        ) : WaitForSuccessException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<WaitForSuccessException> {
        override fun lift(error_buf: RustBuffer.ByValue): WaitForSuccessException = FfiConverterTypeWaitForSuccessError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeWaitForSuccessError : FfiConverterRustBuffer<WaitForSuccessException> {
    override fun read(buf: ByteBuffer): WaitForSuccessException {
        

        return when(buf.getInt()) {
            1 -> WaitForSuccessException.Status(
                FfiConverterTypeStatusError.read(buf),
                )
            2 -> WaitForSuccessException.StatusResponseException(
                FfiConverterTypeStatusResponseError.read(buf),
                )
            3 -> WaitForSuccessException.StatusResponsePending(
                FfiConverterTypeStatusResponsePendingObject.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: WaitForSuccessException): ULong {
        return when(value) {
            is WaitForSuccessException.Status -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeStatusError.allocationSize(value.v1)
            )
            is WaitForSuccessException.StatusResponseException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeStatusResponseError.allocationSize(value.v1)
            )
            is WaitForSuccessException.StatusResponsePending -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeStatusResponsePendingObject.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: WaitForSuccessException, buf: ByteBuffer) {
        when(value) {
            is WaitForSuccessException.Status -> {
                buf.putInt(1)
                FfiConverterTypeStatusError.write(value.v1, buf)
                Unit
            }
            is WaitForSuccessException.StatusResponseException -> {
                buf.putInt(2)
                FfiConverterTypeStatusResponseError.write(value.v1, buf)
                Unit
            }
            is WaitForSuccessException.StatusResponsePending -> {
                buf.putInt(3)
                FfiConverterTypeStatusResponsePendingObject.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}




/**
 * @suppress
 */
public object FfiConverterOptionalULong: FfiConverterRustBuffer<kotlin.ULong?> {
    override fun read(buf: ByteBuffer): kotlin.ULong? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterULong.read(buf)
    }

    override fun allocationSize(value: kotlin.ULong?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterULong.allocationSize(value)
        }
    }

    override fun write(value: kotlin.ULong?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterULong.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalDouble: FfiConverterRustBuffer<kotlin.Double?> {
    override fun read(buf: ByteBuffer): kotlin.Double? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterDouble.read(buf)
    }

    override fun allocationSize(value: kotlin.Double?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterDouble.allocationSize(value)
        }
    }

    override fun write(value: kotlin.Double?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterDouble.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalString: FfiConverterRustBuffer<kotlin.String?> {
    override fun read(buf: ByteBuffer): kotlin.String? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterString.read(buf)
    }

    override fun allocationSize(value: kotlin.String?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterString.allocationSize(value)
        }
    }

    override fun write(value: kotlin.String?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterString.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalByteArray: FfiConverterRustBuffer<kotlin.ByteArray?> {
    override fun read(buf: ByteBuffer): kotlin.ByteArray? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterByteArray.read(buf)
    }

    override fun allocationSize(value: kotlin.ByteArray?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterByteArray.allocationSize(value)
        }
    }

    override fun write(value: kotlin.ByteArray?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterByteArray.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeMetadata: FfiConverterRustBuffer<Metadata?> {
    override fun read(buf: ByteBuffer): Metadata? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeMetadata.read(buf)
    }

    override fun allocationSize(value: Metadata?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeMetadata.allocationSize(value)
        }
    }

    override fun write(value: Metadata?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeMetadata.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypePairingFfi: FfiConverterRustBuffer<PairingFfi?> {
    override fun read(buf: ByteBuffer): PairingFfi? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypePairingFfi.read(buf)
    }

    override fun allocationSize(value: PairingFfi?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypePairingFfi.allocationSize(value)
        }
    }

    override fun write(value: PairingFfi?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypePairingFfi.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeRedirect: FfiConverterRustBuffer<Redirect?> {
    override fun read(buf: ByteBuffer): Redirect? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeRedirect.read(buf)
    }

    override fun allocationSize(value: Redirect?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeRedirect.allocationSize(value)
        }
    }

    override fun write(value: Redirect?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeRedirect.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeSessionFfi: FfiConverterRustBuffer<SessionFfi?> {
    override fun read(buf: ByteBuffer): SessionFfi? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeSessionFfi.read(buf)
    }

    override fun allocationSize(value: SessionFfi?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeSessionFfi.allocationSize(value)
        }
    }

    override fun write(value: SessionFfi?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeSessionFfi.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeTransportType: FfiConverterRustBuffer<TransportType?> {
    override fun read(buf: ByteBuffer): TransportType? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeTransportType.read(buf)
    }

    override fun allocationSize(value: TransportType?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeTransportType.allocationSize(value)
        }
    }

    override fun write(value: TransportType?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeTransportType.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalSequenceString: FfiConverterRustBuffer<List<kotlin.String>?> {
    override fun read(buf: ByteBuffer): List<kotlin.String>? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterSequenceString.read(buf)
    }

    override fun allocationSize(value: List<kotlin.String>?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterSequenceString.allocationSize(value)
        }
    }

    override fun write(value: List<kotlin.String>?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterSequenceString.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalSequenceTypeAssetType: FfiConverterRustBuffer<List<AssetType>?> {
    override fun read(buf: ByteBuffer): List<AssetType>? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterSequenceTypeAssetType.read(buf)
    }

    override fun allocationSize(value: List<AssetType>?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterSequenceTypeAssetType.allocationSize(value)
        }
    }

    override fun write(value: List<AssetType>?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterSequenceTypeAssetType.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalSequenceTypeU64: FfiConverterRustBuffer<List<U64>?> {
    override fun read(buf: ByteBuffer): List<U64>? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterSequenceTypeU64.read(buf)
    }

    override fun allocationSize(value: List<U64>?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterSequenceTypeU64.allocationSize(value)
        }
    }

    override fun write(value: List<U64>?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterSequenceTypeU64.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalMapStringString: FfiConverterRustBuffer<Map<kotlin.String, kotlin.String>?> {
    override fun read(buf: ByteBuffer): Map<kotlin.String, kotlin.String>? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterMapStringString.read(buf)
    }

    override fun allocationSize(value: Map<kotlin.String, kotlin.String>?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterMapStringString.allocationSize(value)
        }
    }

    override fun write(value: Map<kotlin.String, kotlin.String>?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterMapStringString.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalMapStringTypeProposalNamespace: FfiConverterRustBuffer<Map<kotlin.String, ProposalNamespace>?> {
    override fun read(buf: ByteBuffer): Map<kotlin.String, ProposalNamespace>? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterMapStringTypeProposalNamespace.read(buf)
    }

    override fun allocationSize(value: Map<kotlin.String, ProposalNamespace>?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterMapStringTypeProposalNamespace.allocationSize(value)
        }
    }

    override fun write(value: Map<kotlin.String, ProposalNamespace>?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterMapStringTypeProposalNamespace.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalMapTypeU64SequenceTypeAddressOrNative: FfiConverterRustBuffer<Map<U64, List<AddressOrNative>>?> {
    override fun read(buf: ByteBuffer): Map<U64, List<AddressOrNative>>? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterMapTypeU64SequenceTypeAddressOrNative.read(buf)
    }

    override fun allocationSize(value: Map<U64, List<AddressOrNative>>?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterMapTypeU64SequenceTypeAddressOrNative.allocationSize(value)
        }
    }

    override fun write(value: Map<U64, List<AddressOrNative>>?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterMapTypeU64SequenceTypeAddressOrNative.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeAddress: FfiConverterRustBuffer<Address?> {
    override fun read(buf: ByteBuffer): Address? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeAddress.read(buf)
    }

    override fun allocationSize(value: Address?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeAddress.allocationSize(value)
        }
    }

    override fun write(value: Address?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeAddress.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeBytes: FfiConverterRustBuffer<Bytes?> {
    override fun read(buf: ByteBuffer): Bytes? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeBytes.read(buf)
    }

    override fun allocationSize(value: Bytes?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeBytes.allocationSize(value)
        }
    }

    override fun write(value: Bytes?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeBytes.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeU256: FfiConverterRustBuffer<U256?> {
    override fun read(buf: ByteBuffer): U256? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeU256.read(buf)
    }

    override fun allocationSize(value: U256?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeU256.allocationSize(value)
        }
    }

    override fun write(value: U256?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeU256.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeUrl: FfiConverterRustBuffer<Url?> {
    override fun read(buf: ByteBuffer): Url? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeUrl.read(buf)
    }

    override fun allocationSize(value: Url?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeUrl.allocationSize(value)
        }
    }

    override fun write(value: Url?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeUrl.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceString: FfiConverterRustBuffer<List<kotlin.String>> {
    override fun read(buf: ByteBuffer): List<kotlin.String> {
        val len = buf.getInt()
        return List<kotlin.String>(len) {
            FfiConverterString.read(buf)
        }
    }

    override fun allocationSize(value: List<kotlin.String>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterString.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<kotlin.String>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterString.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeEstimation: FfiConverterRustBuffer<List<Estimation>> {
    override fun read(buf: ByteBuffer): List<Estimation> {
        val len = buf.getInt()
        return List<Estimation>(len) {
            FfiConverterTypeEstimation.read(buf)
        }
    }

    override fun allocationSize(value: List<Estimation>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeEstimation.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<Estimation>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeEstimation.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeFundingMetadata: FfiConverterRustBuffer<List<FundingMetadata>> {
    override fun read(buf: ByteBuffer): List<FundingMetadata> {
        val len = buf.getInt()
        return List<FundingMetadata>(len) {
            FfiConverterTypeFundingMetadata.read(buf)
        }
    }

    override fun allocationSize(value: List<FundingMetadata>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeFundingMetadata.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<FundingMetadata>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeFundingMetadata.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeRelay: FfiConverterRustBuffer<List<Relay>> {
    override fun read(buf: ByteBuffer): List<Relay> {
        val len = buf.getInt()
        return List<Relay>(len) {
            FfiConverterTypeRelay.read(buf)
        }
    }

    override fun allocationSize(value: List<Relay>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeRelay.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<Relay>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeRelay.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeSessionFfi: FfiConverterRustBuffer<List<SessionFfi>> {
    override fun read(buf: ByteBuffer): List<SessionFfi> {
        val len = buf.getInt()
        return List<SessionFfi>(len) {
            FfiConverterTypeSessionFfi.read(buf)
        }
    }

    override fun allocationSize(value: List<SessionFfi>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeSessionFfi.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<SessionFfi>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeSessionFfi.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeSolanaTransaction: FfiConverterRustBuffer<List<SolanaTransaction>> {
    override fun read(buf: ByteBuffer): List<SolanaTransaction> {
        val len = buf.getInt()
        return List<SolanaTransaction>(len) {
            FfiConverterTypeSolanaTransaction.read(buf)
        }
    }

    override fun allocationSize(value: List<SolanaTransaction>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeSolanaTransaction.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<SolanaTransaction>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeSolanaTransaction.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeSolanaTxnDetails: FfiConverterRustBuffer<List<SolanaTxnDetails>> {
    override fun read(buf: ByteBuffer): List<SolanaTxnDetails> {
        val len = buf.getInt()
        return List<SolanaTxnDetails>(len) {
            FfiConverterTypeSolanaTxnDetails.read(buf)
        }
    }

    override fun allocationSize(value: List<SolanaTxnDetails>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeSolanaTxnDetails.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<SolanaTxnDetails>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeSolanaTxnDetails.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeTransaction: FfiConverterRustBuffer<List<Transaction>> {
    override fun read(buf: ByteBuffer): List<Transaction> {
        val len = buf.getInt()
        return List<Transaction>(len) {
            FfiConverterTypeTransaction.read(buf)
        }
    }

    override fun allocationSize(value: List<Transaction>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeTransaction.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<Transaction>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeTransaction.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeTransactionFee: FfiConverterRustBuffer<List<TransactionFee>> {
    override fun read(buf: ByteBuffer): List<TransactionFee> {
        val len = buf.getInt()
        return List<TransactionFee>(len) {
            FfiConverterTypeTransactionFee.read(buf)
        }
    }

    override fun allocationSize(value: List<TransactionFee>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeTransactionFee.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<TransactionFee>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeTransactionFee.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeTxnDetails: FfiConverterRustBuffer<List<TxnDetails>> {
    override fun read(buf: ByteBuffer): List<TxnDetails> {
        val len = buf.getInt()
        return List<TxnDetails>(len) {
            FfiConverterTypeTxnDetails.read(buf)
        }
    }

    override fun allocationSize(value: List<TxnDetails>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeTxnDetails.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<TxnDetails>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeTxnDetails.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeAddressOrNative: FfiConverterRustBuffer<List<AddressOrNative>> {
    override fun read(buf: ByteBuffer): List<AddressOrNative> {
        val len = buf.getInt()
        return List<AddressOrNative>(len) {
            FfiConverterTypeAddressOrNative.read(buf)
        }
    }

    override fun allocationSize(value: List<AddressOrNative>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeAddressOrNative.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<AddressOrNative>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeAddressOrNative.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeAssetType: FfiConverterRustBuffer<List<AssetType>> {
    override fun read(buf: ByteBuffer): List<AssetType> {
        val len = buf.getInt()
        return List<AssetType>(len) {
            FfiConverterTypeAssetType.read(buf)
        }
    }

    override fun allocationSize(value: List<AssetType>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeAssetType.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<AssetType>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeAssetType.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeRoute: FfiConverterRustBuffer<List<Route>> {
    override fun read(buf: ByteBuffer): List<Route> {
        val len = buf.getInt()
        return List<Route>(len) {
            FfiConverterTypeRoute.read(buf)
        }
    }

    override fun allocationSize(value: List<Route>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeRoute.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<Route>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeRoute.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeTransactions: FfiConverterRustBuffer<List<Transactions>> {
    override fun read(buf: ByteBuffer): List<Transactions> {
        val len = buf.getInt()
        return List<Transactions>(len) {
            FfiConverterTypeTransactions.read(buf)
        }
    }

    override fun allocationSize(value: List<Transactions>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeTransactions.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<Transactions>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeTransactions.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeBalance: FfiConverterRustBuffer<List<Balance>> {
    override fun read(buf: ByteBuffer): List<Balance> {
        val len = buf.getInt()
        return List<Balance>(len) {
            FfiConverterTypeBalance.read(buf)
        }
    }

    override fun allocationSize(value: List<Balance>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeBalance.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<Balance>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeBalance.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypePrimitiveSignature: FfiConverterRustBuffer<List<PrimitiveSignature>> {
    override fun read(buf: ByteBuffer): List<PrimitiveSignature> {
        val len = buf.getInt()
        return List<PrimitiveSignature>(len) {
            FfiConverterTypePrimitiveSignature.read(buf)
        }
    }

    override fun allocationSize(value: List<PrimitiveSignature>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypePrimitiveSignature.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<PrimitiveSignature>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypePrimitiveSignature.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeSolanaSignature: FfiConverterRustBuffer<List<SolanaSignature>> {
    override fun read(buf: ByteBuffer): List<SolanaSignature> {
        val len = buf.getInt()
        return List<SolanaSignature>(len) {
            FfiConverterTypeSolanaSignature.read(buf)
        }
    }

    override fun allocationSize(value: List<SolanaSignature>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeSolanaSignature.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<SolanaSignature>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeSolanaSignature.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeTopic: FfiConverterRustBuffer<List<Topic>> {
    override fun read(buf: ByteBuffer): List<Topic> {
        val len = buf.getInt()
        return List<Topic>(len) {
            FfiConverterTypeTopic.read(buf)
        }
    }

    override fun allocationSize(value: List<Topic>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeTopic.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<Topic>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeTopic.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeU64: FfiConverterRustBuffer<List<U64>> {
    override fun read(buf: ByteBuffer): List<U64> {
        val len = buf.getInt()
        return List<U64>(len) {
            FfiConverterTypeU64.read(buf)
        }
    }

    override fun allocationSize(value: List<U64>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeU64.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<U64>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeU64.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterMapStringString: FfiConverterRustBuffer<Map<kotlin.String, kotlin.String>> {
    override fun read(buf: ByteBuffer): Map<kotlin.String, kotlin.String> {
        val len = buf.getInt()
        return buildMap<kotlin.String, kotlin.String>(len) {
            repeat(len) {
                val k = FfiConverterString.read(buf)
                val v = FfiConverterString.read(buf)
                this[k] = v
            }
        }
    }

    override fun allocationSize(value: Map<kotlin.String, kotlin.String>): ULong {
        val spaceForMapSize = 4UL
        val spaceForChildren = value.map { (k, v) ->
            FfiConverterString.allocationSize(k) +
            FfiConverterString.allocationSize(v)
        }.sum()
        return spaceForMapSize + spaceForChildren
    }

    override fun write(value: Map<kotlin.String, kotlin.String>, buf: ByteBuffer) {
        buf.putInt(value.size)
        // The parens on `(k, v)` here ensure we're calling the right method,
        // which is important for compatibility with older android devices.
        // Ref https://blog.danlew.net/2017/03/16/kotlin-puzzler-whose-line-is-it-anyways/
        value.forEach { (k, v) ->
            FfiConverterString.write(k, buf)
            FfiConverterString.write(v, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterMapStringTypeProposalNamespace: FfiConverterRustBuffer<Map<kotlin.String, ProposalNamespace>> {
    override fun read(buf: ByteBuffer): Map<kotlin.String, ProposalNamespace> {
        val len = buf.getInt()
        return buildMap<kotlin.String, ProposalNamespace>(len) {
            repeat(len) {
                val k = FfiConverterString.read(buf)
                val v = FfiConverterTypeProposalNamespace.read(buf)
                this[k] = v
            }
        }
    }

    override fun allocationSize(value: Map<kotlin.String, ProposalNamespace>): ULong {
        val spaceForMapSize = 4UL
        val spaceForChildren = value.map { (k, v) ->
            FfiConverterString.allocationSize(k) +
            FfiConverterTypeProposalNamespace.allocationSize(v)
        }.sum()
        return spaceForMapSize + spaceForChildren
    }

    override fun write(value: Map<kotlin.String, ProposalNamespace>, buf: ByteBuffer) {
        buf.putInt(value.size)
        // The parens on `(k, v)` here ensure we're calling the right method,
        // which is important for compatibility with older android devices.
        // Ref https://blog.danlew.net/2017/03/16/kotlin-puzzler-whose-line-is-it-anyways/
        value.forEach { (k, v) ->
            FfiConverterString.write(k, buf)
            FfiConverterTypeProposalNamespace.write(v, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterMapStringTypeSettleNamespace: FfiConverterRustBuffer<Map<kotlin.String, SettleNamespace>> {
    override fun read(buf: ByteBuffer): Map<kotlin.String, SettleNamespace> {
        val len = buf.getInt()
        return buildMap<kotlin.String, SettleNamespace>(len) {
            repeat(len) {
                val k = FfiConverterString.read(buf)
                val v = FfiConverterTypeSettleNamespace.read(buf)
                this[k] = v
            }
        }
    }

    override fun allocationSize(value: Map<kotlin.String, SettleNamespace>): ULong {
        val spaceForMapSize = 4UL
        val spaceForChildren = value.map { (k, v) ->
            FfiConverterString.allocationSize(k) +
            FfiConverterTypeSettleNamespace.allocationSize(v)
        }.sum()
        return spaceForMapSize + spaceForChildren
    }

    override fun write(value: Map<kotlin.String, SettleNamespace>, buf: ByteBuffer) {
        buf.putInt(value.size)
        // The parens on `(k, v)` here ensure we're calling the right method,
        // which is important for compatibility with older android devices.
        // Ref https://blog.danlew.net/2017/03/16/kotlin-puzzler-whose-line-is-it-anyways/
        value.forEach { (k, v) ->
            FfiConverterString.write(k, buf)
            FfiConverterTypeSettleNamespace.write(v, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterMapTypeU64SequenceTypeAddressOrNative: FfiConverterRustBuffer<Map<U64, List<AddressOrNative>>> {
    override fun read(buf: ByteBuffer): Map<U64, List<AddressOrNative>> {
        val len = buf.getInt()
        return buildMap<U64, List<AddressOrNative>>(len) {
            repeat(len) {
                val k = FfiConverterTypeU64.read(buf)
                val v = FfiConverterSequenceTypeAddressOrNative.read(buf)
                this[k] = v
            }
        }
    }

    override fun allocationSize(value: Map<U64, List<AddressOrNative>>): ULong {
        val spaceForMapSize = 4UL
        val spaceForChildren = value.map { (k, v) ->
            FfiConverterTypeU64.allocationSize(k) +
            FfiConverterSequenceTypeAddressOrNative.allocationSize(v)
        }.sum()
        return spaceForMapSize + spaceForChildren
    }

    override fun write(value: Map<U64, List<AddressOrNative>>, buf: ByteBuffer) {
        buf.putInt(value.size)
        // The parens on `(k, v)` here ensure we're calling the right method,
        // which is important for compatibility with older android devices.
        // Ref https://blog.danlew.net/2017/03/16/kotlin-puzzler-whose-line-is-it-anyways/
        value.forEach { (k, v) ->
            FfiConverterTypeU64.write(k, buf)
            FfiConverterSequenceTypeAddressOrNative.write(v, buf)
        }
    }
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias AccountAddress = Address
public typealias FfiConverterTypeAccountAddress = FfiConverterTypeAddress



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias Address = kotlin.String
public typealias FfiConverterTypeAddress = FfiConverterString



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias AlloyError = kotlin.String
public typealias FfiConverterTypeAlloyError = FfiConverterString



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias AnyhowError = kotlin.String
public typealias FfiConverterTypeAnyhowError = FfiConverterString



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias Asset = AssetFfi
public typealias FfiConverterTypeAsset = FfiConverterTypeAssetFfi



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias Authorization = FfiAuthorization
public typealias FfiConverterTypeAuthorization = FfiConverterTypeFfiAuthorization



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias B256 = kotlin.String
public typealias FfiConverterTypeB256 = FfiConverterString



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias Balance = BalanceFfi
public typealias FfiConverterTypeBalance = FfiConverterTypeBalanceFfi



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias Bytes = kotlin.String
public typealias FfiConverterTypeBytes = FfiConverterString



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias ClarityError = kotlin.String
public typealias FfiConverterTypeClarityError = FfiConverterString



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias ClientId = kotlin.String
public typealias FfiConverterTypeClientId = FfiConverterString



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias Eip155OrSolanaAddress = kotlin.String
public typealias FfiConverterTypeEip155OrSolanaAddress = FfiConverterString



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias Eip712Domain = kotlin.String
public typealias FfiConverterTypeEip712Domain = FfiConverterString



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias EyreError = kotlin.String
public typealias FfiConverterTypeEyreError = FfiConverterString



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias Id = kotlin.String
public typealias FfiConverterTypeId = FfiConverterString



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias PendingTransactionError = kotlin.String
public typealias FfiConverterTypePendingTransactionError = FfiConverterString



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias PrimitiveSignature = kotlin.String
public typealias FfiConverterTypePrimitiveSignature = FfiConverterString



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias PrivateKeySigner = kotlin.String
public typealias FfiConverterTypePrivateKeySigner = FfiConverterString



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias ProjectId = kotlin.String
public typealias FfiConverterTypeProjectId = FfiConverterString



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias PublicKey = kotlin.String
public typealias FfiConverterTypePublicKey = FfiConverterString



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias ReqwestError = kotlin.String
public typealias FfiConverterTypeReqwestError = FfiConverterString



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias RpcError = kotlin.String
public typealias FfiConverterTypeRpcError = FfiConverterString



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias SerdeJsonError = kotlin.String
public typealias FfiConverterTypeSerdeJsonError = FfiConverterString



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias Signature = kotlin.String
public typealias FfiConverterTypeSignature = FfiConverterString



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias SolanaKeypair = kotlin.String
public typealias FfiConverterTypeSolanaKeypair = FfiConverterString



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias SolanaPubkey = kotlin.String
public typealias FfiConverterTypeSolanaPubkey = FfiConverterString



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias SolanaSignature = kotlin.String
public typealias FfiConverterTypeSolanaSignature = FfiConverterString



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias StacksSignature = kotlin.String
public typealias FfiConverterTypeStacksSignature = FfiConverterString



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias StacksTransactionError = kotlin.String
public typealias FfiConverterTypeStacksTransactionError = FfiConverterString



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias StacksWalletError = kotlin.String
public typealias FfiConverterTypeStacksWalletError = FfiConverterString



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias StatusCode = kotlin.UShort
public typealias FfiConverterTypeStatusCode = FfiConverterUShort



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias SuiAddress = kotlin.String
public typealias FfiConverterTypeSuiAddress = FfiConverterString



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias SuiKeyPair = kotlin.String
public typealias FfiConverterTypeSuiKeyPair = FfiConverterString



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias SuiSdkError = kotlin.String
public typealias FfiConverterTypeSuiSdkError = FfiConverterString



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias Topic = kotlin.String
public typealias FfiConverterTypeTopic = FfiConverterString



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias TransactionDigest = kotlin.String
public typealias FfiConverterTypeTransactionDigest = FfiConverterString



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias TransactionReceipt = kotlin.String
public typealias FfiConverterTypeTransactionReceipt = FfiConverterString



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias U128 = kotlin.String
public typealias FfiConverterTypeU128 = FfiConverterString



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias U128Primitive = kotlin.String
public typealias FfiConverterTypeU128Primitive = FfiConverterString



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias U256 = kotlin.String
public typealias FfiConverterTypeU256 = FfiConverterString



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias U48 = kotlin.String
public typealias FfiConverterTypeU48 = FfiConverterString



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias U64 = kotlin.String
public typealias FfiConverterTypeU64 = FfiConverterString



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias U8 = kotlin.String
public typealias FfiConverterTypeU8 = FfiConverterString



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias Url = kotlin.String
public typealias FfiConverterTypeUrl = FfiConverterString



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias UserOperationReceipt = kotlin.String
public typealias FfiConverterTypeUserOperationReceipt = FfiConverterString



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias VersionedTransaction = kotlin.String
public typealias FfiConverterTypeVersionedTransaction = FfiConverterString







 fun `errorDataFfiFromJson`(`json`: kotlin.String): ErrorDataFfi {
            return FfiConverterTypeErrorDataFfi.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_func_error_data_ffi_from_json(
        FfiConverterString.lower(`json`),_status)
}
    )
    }
    
 fun `errorDataFfiToJson`(`object`: ErrorDataFfi): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_func_error_data_ffi_to_json(
        FfiConverterTypeErrorDataFfi.lower(`object`),_status)
}
    )
    }
    
 fun `fundingMetadataToAmount`(`value`: FundingMetadata): Amount {
            return FfiConverterTypeAmount.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_func_funding_metadata_to_amount(
        FfiConverterTypeFundingMetadata.lower(`value`),_status)
}
    )
    }
    
 fun `fundingMetadataToBridgingFeeAmount`(`value`: FundingMetadata): Amount {
            return FfiConverterTypeAmount.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_func_funding_metadata_to_bridging_fee_amount(
        FfiConverterTypeFundingMetadata.lower(`value`),_status)
}
    )
    }
    
 fun `metadataFromJson`(`json`: kotlin.String): Metadata {
            return FfiConverterTypeMetadata.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_func_metadata_from_json(
        FfiConverterString.lower(`json`),_status)
}
    )
    }
    
 fun `metadataToJson`(`object`: Metadata): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_func_metadata_to_json(
        FfiConverterTypeMetadata.lower(`object`),_status)
}
    )
    }
    
 fun `proposalNamespaceFromJson`(`json`: kotlin.String): ProposalNamespace {
            return FfiConverterTypeProposalNamespace.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_func_proposal_namespace_from_json(
        FfiConverterString.lower(`json`),_status)
}
    )
    }
    
 fun `proposalNamespaceToJson`(`object`: ProposalNamespace): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_func_proposal_namespace_to_json(
        FfiConverterTypeProposalNamespace.lower(`object`),_status)
}
    )
    }
    
 fun `redirectFromJson`(`json`: kotlin.String): Redirect {
            return FfiConverterTypeRedirect.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_func_redirect_from_json(
        FfiConverterString.lower(`json`),_status)
}
    )
    }
    
 fun `redirectToJson`(`object`: Redirect): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_func_redirect_to_json(
        FfiConverterTypeRedirect.lower(`object`),_status)
}
    )
    }
    
 fun `registerLogger`(`logger`: Logger)
        = 
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_func_register_logger(
        FfiConverterTypeLogger.lower(`logger`),_status)
}
    
    
 fun `relayFromJson`(`json`: kotlin.String): Relay {
            return FfiConverterTypeRelay.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_func_relay_from_json(
        FfiConverterString.lower(`json`),_status)
}
    )
    }
    
 fun `relayToJson`(`object`: Relay): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_func_relay_to_json(
        FfiConverterTypeRelay.lower(`object`),_status)
}
    )
    }
    
 fun `sessionFfiFromJson`(`json`: kotlin.String): SessionFfi {
            return FfiConverterTypeSessionFfi.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_func_session_ffi_from_json(
        FfiConverterString.lower(`json`),_status)
}
    )
    }
    
 fun `sessionFfiToJson`(`object`: SessionFfi): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_func_session_ffi_to_json(
        FfiConverterTypeSessionFfi.lower(`object`),_status)
}
    )
    }
    
 fun `sessionProposalFfiFromJson`(`json`: kotlin.String): SessionProposalFfi {
            return FfiConverterTypeSessionProposalFfi.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_func_session_proposal_ffi_from_json(
        FfiConverterString.lower(`json`),_status)
}
    )
    }
    
 fun `sessionProposalFfiToJson`(`object`: SessionProposalFfi): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_func_session_proposal_ffi_to_json(
        FfiConverterTypeSessionProposalFfi.lower(`object`),_status)
}
    )
    }
    
 fun `sessionRequestFfiFromJson`(`json`: kotlin.String): SessionRequestFfi {
            return FfiConverterTypeSessionRequestFfi.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_func_session_request_ffi_from_json(
        FfiConverterString.lower(`json`),_status)
}
    )
    }
    
 fun `sessionRequestFfiToJson`(`object`: SessionRequestFfi): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_func_session_request_ffi_to_json(
        FfiConverterTypeSessionRequestFfi.lower(`object`),_status)
}
    )
    }
    
 fun `sessionRequestJsonRpcErrorResponseFfiFromJson`(`json`: kotlin.String): SessionRequestJsonRpcErrorResponseFfi {
            return FfiConverterTypeSessionRequestJsonRpcErrorResponseFfi.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_func_session_request_json_rpc_error_response_ffi_from_json(
        FfiConverterString.lower(`json`),_status)
}
    )
    }
    
 fun `sessionRequestJsonRpcErrorResponseFfiToJson`(`object`: SessionRequestJsonRpcErrorResponseFfi): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_func_session_request_json_rpc_error_response_ffi_to_json(
        FfiConverterTypeSessionRequestJsonRpcErrorResponseFfi.lower(`object`),_status)
}
    )
    }
    
 fun `sessionRequestJsonRpcFfiFromJson`(`json`: kotlin.String): SessionRequestJsonRpcFfi {
            return FfiConverterTypeSessionRequestJsonRpcFfi.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_func_session_request_json_rpc_ffi_from_json(
        FfiConverterString.lower(`json`),_status)
}
    )
    }
    
 fun `sessionRequestJsonRpcFfiToJson`(`object`: SessionRequestJsonRpcFfi): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_func_session_request_json_rpc_ffi_to_json(
        FfiConverterTypeSessionRequestJsonRpcFfi.lower(`object`),_status)
}
    )
    }
    
 fun `sessionRequestJsonRpcResultResponseFfiFromJson`(`json`: kotlin.String): SessionRequestJsonRpcResultResponseFfi {
            return FfiConverterTypeSessionRequestJsonRpcResultResponseFfi.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_func_session_request_json_rpc_result_response_ffi_from_json(
        FfiConverterString.lower(`json`),_status)
}
    )
    }
    
 fun `sessionRequestJsonRpcResultResponseFfiToJson`(`object`: SessionRequestJsonRpcResultResponseFfi): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_func_session_request_json_rpc_result_response_ffi_to_json(
        FfiConverterTypeSessionRequestJsonRpcResultResponseFfi.lower(`object`),_status)
}
    )
    }
    
 fun `sessionRequestRequestFfiToJson`(`object`: SessionRequestRequestFfi): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_func_session_request_request_ffi_to_json(
        FfiConverterTypeSessionRequestRequestFfi.lower(`object`),_status)
}
    )
    }
    
 fun `sessionRequestRequestFromJson`(`json`: kotlin.String): SessionRequestRequestFfi {
            return FfiConverterTypeSessionRequestRequestFfi.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_func_session_request_request_from_json(
        FfiConverterString.lower(`json`),_status)
}
    )
    }
    
 fun `settleNamespaceFromJson`(`json`: kotlin.String): SettleNamespace {
            return FfiConverterTypeSettleNamespace.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_func_settle_namespace_from_json(
        FfiConverterString.lower(`json`),_status)
}
    )
    }
    
 fun `settleNamespaceToJson`(`object`: SettleNamespace): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_func_settle_namespace_to_json(
        FfiConverterTypeSettleNamespace.lower(`object`),_status)
}
    )
    }
    

    @Throws(SolanaDeriveKeypairFromMnemonicException::class) fun `solanaDeriveKeypairFromMnemonic`(`mnemonic`: kotlin.String, `derivationPath`: kotlin.String?): SolanaKeypair {
            return FfiConverterTypeSolanaKeypair.lift(
    uniffiRustCallWithError(SolanaDeriveKeypairFromMnemonicException) { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_func_solana_derive_keypair_from_mnemonic(
        FfiConverterString.lower(`mnemonic`),FfiConverterOptionalString.lower(`derivationPath`),_status)
}
    )
    }
    
 fun `solanaGenerateKeypair`(): SolanaKeypair {
            return FfiConverterTypeSolanaKeypair.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_func_solana_generate_keypair(
        _status)
}
    )
    }
    
 fun `solanaPhantomDerivationPathWithAccount`(`account`: kotlin.UInt): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_func_solana_phantom_derivation_path_with_account(
        FfiConverterUInt.lower(`account`),_status)
}
    )
    }
    
 fun `solanaPubkeyForKeypair`(`keypair`: SolanaKeypair): SolanaPubkey {
            return FfiConverterTypeSolanaPubkey.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_func_solana_pubkey_for_keypair(
        FfiConverterTypeSolanaKeypair.lower(`keypair`),_status)
}
    )
    }
    
 fun `solanaSignPrehash`(`keypair`: SolanaKeypair, `message`: Bytes): SolanaSignature {
            return FfiConverterTypeSolanaSignature.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_func_solana_sign_prehash(
        FfiConverterTypeSolanaKeypair.lower(`keypair`),FfiConverterTypeBytes.lower(`message`),_status)
}
    )
    }
    
 fun `stacksGenerateWallet`(): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_func_stacks_generate_wallet(
        _status)
}
    )
    }
    

    @Throws(StacksGetAddressException::class) fun `stacksGetAddress`(`wallet`: kotlin.String, `version`: kotlin.String): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCallWithError(StacksGetAddressException) { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_func_stacks_get_address(
        FfiConverterString.lower(`wallet`),FfiConverterString.lower(`version`),_status)
}
    )
    }
    

    @Throws(StacksSignMessageException::class) fun `stacksSignMessage`(`wallet`: kotlin.String, `message`: kotlin.String): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCallWithError(StacksSignMessageException) { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_func_stacks_sign_message(
        FfiConverterString.lower(`wallet`),FfiConverterString.lower(`message`),_status)
}
    )
    }
    

    @Throws(DeriveKeypairFromMnemonicException::class) fun `suiDeriveKeypairFromMnemonic`(`mnemonic`: kotlin.String): SuiKeyPair {
            return FfiConverterTypeSuiKeyPair.lift(
    uniffiRustCallWithError(DeriveKeypairFromMnemonicException) { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_func_sui_derive_keypair_from_mnemonic(
        FfiConverterString.lower(`mnemonic`),_status)
}
    )
    }
    
 fun `suiGenerateKeypair`(): SuiKeyPair {
            return FfiConverterTypeSuiKeyPair.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_func_sui_generate_keypair(
        _status)
}
    )
    }
    
 fun `suiGetAddress`(`publicKey`: PublicKey): SuiAddress {
            return FfiConverterTypeSuiAddress.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_func_sui_get_address(
        FfiConverterTypePublicKey.lower(`publicKey`),_status)
}
    )
    }
    
 fun `suiGetPublicKey`(`keypair`: SuiKeyPair): PublicKey {
            return FfiConverterTypePublicKey.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_func_sui_get_public_key(
        FfiConverterTypeSuiKeyPair.lower(`keypair`),_status)
}
    )
    }
    
 fun `suiPersonalSign`(`keypair`: SuiKeyPair, `message`: kotlin.ByteArray): Signature {
            return FfiConverterTypeSignature.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_yttrium_fn_func_sui_personal_sign(
        FfiConverterTypeSuiKeyPair.lower(`keypair`),FfiConverterByteArray.lower(`message`),_status)
}
    )
    }
    


