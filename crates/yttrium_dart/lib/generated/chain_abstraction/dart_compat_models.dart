// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.7.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'api/prepare.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'dart_compat_models.freezed.dart';

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ExecuteDetailsCompat>>
abstract class ExecuteDetailsCompat implements RustOpaqueInterface {}

class AmountCompat {
  final String symbol;
  final String amount;
  final int unit;
  final String formatted;
  final String formattedAlt;

  const AmountCompat({
    required this.symbol,
    required this.amount,
    required this.unit,
    required this.formatted,
    required this.formattedAlt,
  });

  @override
  int get hashCode =>
      symbol.hashCode ^
      amount.hashCode ^
      unit.hashCode ^
      formatted.hashCode ^
      formattedAlt.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AmountCompat &&
          runtimeType == other.runtimeType &&
          symbol == other.symbol &&
          amount == other.amount &&
          unit == other.unit &&
          formatted == other.formatted &&
          formattedAlt == other.formattedAlt;
}

class CallCompat {
  final String to;
  final BigInt value;
  final Uint8List input;

  const CallCompat({
    required this.to,
    required this.value,
    required this.input,
  });

  @override
  int get hashCode => to.hashCode ^ value.hashCode ^ input.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CallCompat &&
          runtimeType == other.runtimeType &&
          to == other.to &&
          value == other.value &&
          input == other.input;
}

class Eip1559EstimationCompat {
  /// The base fee per gas as a String.
  final String maxFeePerGas;

  /// The max priority fee per gas as a String.
  final String maxPriorityFeePerGas;

  const Eip1559EstimationCompat({
    required this.maxFeePerGas,
    required this.maxPriorityFeePerGas,
  });

  @override
  int get hashCode => maxFeePerGas.hashCode ^ maxPriorityFeePerGas.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Eip1559EstimationCompat &&
          runtimeType == other.runtimeType &&
          maxFeePerGas == other.maxFeePerGas &&
          maxPriorityFeePerGas == other.maxPriorityFeePerGas;
}

@freezed
sealed class ErrorCompat with _$ErrorCompat implements FrbException {
  const ErrorCompat._();

  const factory ErrorCompat.general(
    String field0,
  ) = ErrorCompat_General;
}

class FeeEstimatedTransactionCompat {
  final String chainId;
  final String from;
  final String to;
  final String value;
  final Uint8List input;
  final String gasLimit;
  final String nonce;
  final String maxFeePerGas;
  final String maxPriorityFeePerGas;

  const FeeEstimatedTransactionCompat({
    required this.chainId,
    required this.from,
    required this.to,
    required this.value,
    required this.input,
    required this.gasLimit,
    required this.nonce,
    required this.maxFeePerGas,
    required this.maxPriorityFeePerGas,
  });

  @override
  int get hashCode =>
      chainId.hashCode ^
      from.hashCode ^
      to.hashCode ^
      value.hashCode ^
      input.hashCode ^
      gasLimit.hashCode ^
      nonce.hashCode ^
      maxFeePerGas.hashCode ^
      maxPriorityFeePerGas.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FeeEstimatedTransactionCompat &&
          runtimeType == other.runtimeType &&
          chainId == other.chainId &&
          from == other.from &&
          to == other.to &&
          value == other.value &&
          input == other.input &&
          gasLimit == other.gasLimit &&
          nonce == other.nonce &&
          maxFeePerGas == other.maxFeePerGas &&
          maxPriorityFeePerGas == other.maxPriorityFeePerGas;
}

class FundingMetadataCompat {
  final String chainId;
  final String tokenContract;
  final String symbol;
  final String amount;
  final String bridgingFee;
  final int decimals;

  const FundingMetadataCompat({
    required this.chainId,
    required this.tokenContract,
    required this.symbol,
    required this.amount,
    required this.bridgingFee,
    required this.decimals,
  });

  @override
  int get hashCode =>
      chainId.hashCode ^
      tokenContract.hashCode ^
      symbol.hashCode ^
      amount.hashCode ^
      bridgingFee.hashCode ^
      decimals.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FundingMetadataCompat &&
          runtimeType == other.runtimeType &&
          chainId == other.chainId &&
          tokenContract == other.tokenContract &&
          symbol == other.symbol &&
          amount == other.amount &&
          bridgingFee == other.bridgingFee &&
          decimals == other.decimals;
}

class InitialTransactionMetadataCompat {
  final String transferTo;
  final String amount;
  final String tokenContract;
  final String symbol;
  final int decimals;

  const InitialTransactionMetadataCompat({
    required this.transferTo,
    required this.amount,
    required this.tokenContract,
    required this.symbol,
    required this.decimals,
  });

  @override
  int get hashCode =>
      transferTo.hashCode ^
      amount.hashCode ^
      tokenContract.hashCode ^
      symbol.hashCode ^
      decimals.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is InitialTransactionMetadataCompat &&
          runtimeType == other.runtimeType &&
          transferTo == other.transferTo &&
          amount == other.amount &&
          tokenContract == other.tokenContract &&
          symbol == other.symbol &&
          decimals == other.decimals;
}

class MetadataCompat {
  final List<FundingMetadataCompat> fundingFrom;
  final InitialTransactionMetadataCompat initialTransaction;
  final BigInt checkIn;

  const MetadataCompat({
    required this.fundingFrom,
    required this.initialTransaction,
    required this.checkIn,
  });

  @override
  int get hashCode =>
      fundingFrom.hashCode ^ initialTransaction.hashCode ^ checkIn.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MetadataCompat &&
          runtimeType == other.runtimeType &&
          fundingFrom == other.fundingFrom &&
          initialTransaction == other.initialTransaction &&
          checkIn == other.checkIn;
}

@freezed
sealed class PrepareDetailedResponseCompat
    with _$PrepareDetailedResponseCompat {
  const PrepareDetailedResponseCompat._();

  const factory PrepareDetailedResponseCompat.success(
    PrepareDetailedResponseSuccessCompat field0,
  ) = PrepareDetailedResponseCompat_Success;
  const factory PrepareDetailedResponseCompat.error(
    PrepareResponseError field0,
  ) = PrepareDetailedResponseCompat_Error;
}

@freezed
sealed class PrepareDetailedResponseSuccessCompat
    with _$PrepareDetailedResponseSuccessCompat {
  const PrepareDetailedResponseSuccessCompat._();

  const factory PrepareDetailedResponseSuccessCompat.available(
    UiFieldsCompat field0,
  ) = PrepareDetailedResponseSuccessCompat_Available;
  const factory PrepareDetailedResponseSuccessCompat.notRequired(
    PrepareResponseNotRequiredCompat field0,
  ) = PrepareDetailedResponseSuccessCompat_NotRequired;
}

class PrepareResponseAvailableCompat {
  final String orchestrationId;
  final TransactionCompat initialTransaction;
  final List<TransactionCompat> transactions;
  final MetadataCompat metadata;

  const PrepareResponseAvailableCompat({
    required this.orchestrationId,
    required this.initialTransaction,
    required this.transactions,
    required this.metadata,
  });

  @override
  int get hashCode =>
      orchestrationId.hashCode ^
      initialTransaction.hashCode ^
      transactions.hashCode ^
      metadata.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PrepareResponseAvailableCompat &&
          runtimeType == other.runtimeType &&
          orchestrationId == other.orchestrationId &&
          initialTransaction == other.initialTransaction &&
          transactions == other.transactions &&
          metadata == other.metadata;
}

class PrepareResponseNotRequiredCompat {
  final TransactionCompat initialTransaction;
  final List<TransactionCompat> transactions;

  const PrepareResponseNotRequiredCompat({
    required this.initialTransaction,
    required this.transactions,
  });

  @override
  int get hashCode => initialTransaction.hashCode ^ transactions.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PrepareResponseNotRequiredCompat &&
          runtimeType == other.runtimeType &&
          initialTransaction == other.initialTransaction &&
          transactions == other.transactions;
}

class PrimitiveSignatureCompat {
  final bool yParity;
  final String r;
  final String s;

  const PrimitiveSignatureCompat({
    required this.yParity,
    required this.r,
    required this.s,
  });

  @override
  int get hashCode => yParity.hashCode ^ r.hashCode ^ s.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PrimitiveSignatureCompat &&
          runtimeType == other.runtimeType &&
          yParity == other.yParity &&
          r == other.r &&
          s == other.s;
}

class PulseMetadataCompat {
  final String? url;
  final String? bundleId;
  final String? packageName;
  final String sdkVersion;
  final String sdkPlatform;

  const PulseMetadataCompat({
    this.url,
    this.bundleId,
    this.packageName,
    required this.sdkVersion,
    required this.sdkPlatform,
  });

  @override
  int get hashCode =>
      url.hashCode ^
      bundleId.hashCode ^
      packageName.hashCode ^
      sdkVersion.hashCode ^
      sdkPlatform.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PulseMetadataCompat &&
          runtimeType == other.runtimeType &&
          url == other.url &&
          bundleId == other.bundleId &&
          packageName == other.packageName &&
          sdkVersion == other.sdkVersion &&
          sdkPlatform == other.sdkPlatform;
}

class TransactionCompat {
  final String chainId;
  final String from;
  final String to;
  final String value;
  final Uint8List input;
  final BigInt gasLimit;
  final BigInt nonce;

  const TransactionCompat({
    required this.chainId,
    required this.from,
    required this.to,
    required this.value,
    required this.input,
    required this.gasLimit,
    required this.nonce,
  });

  @override
  int get hashCode =>
      chainId.hashCode ^
      from.hashCode ^
      to.hashCode ^
      value.hashCode ^
      input.hashCode ^
      gasLimit.hashCode ^
      nonce.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TransactionCompat &&
          runtimeType == other.runtimeType &&
          chainId == other.chainId &&
          from == other.from &&
          to == other.to &&
          value == other.value &&
          input == other.input &&
          gasLimit == other.gasLimit &&
          nonce == other.nonce;
}

class TransactionFeeCompat {
  final AmountCompat fee;
  final AmountCompat localFee;

  const TransactionFeeCompat({
    required this.fee,
    required this.localFee,
  });

  @override
  int get hashCode => fee.hashCode ^ localFee.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TransactionFeeCompat &&
          runtimeType == other.runtimeType &&
          fee == other.fee &&
          localFee == other.localFee;
}

class TxnDetailsCompat {
  final FeeEstimatedTransactionCompat transaction;
  final String transactionHashToSign;
  final TransactionFeeCompat fee;

  const TxnDetailsCompat({
    required this.transaction,
    required this.transactionHashToSign,
    required this.fee,
  });

  @override
  int get hashCode =>
      transaction.hashCode ^ transactionHashToSign.hashCode ^ fee.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TxnDetailsCompat &&
          runtimeType == other.runtimeType &&
          transaction == other.transaction &&
          transactionHashToSign == other.transactionHashToSign &&
          fee == other.fee;
}

class UiFieldsCompat {
  final PrepareResponseAvailableCompat routeResponse;
  final List<TxnDetailsCompat> route;
  final AmountCompat localRouteTotal;
  final List<TransactionFeeCompat> bridge;
  final AmountCompat localBridgeTotal;
  final TxnDetailsCompat initial;
  final AmountCompat localTotal;

  const UiFieldsCompat({
    required this.routeResponse,
    required this.route,
    required this.localRouteTotal,
    required this.bridge,
    required this.localBridgeTotal,
    required this.initial,
    required this.localTotal,
  });

  @override
  int get hashCode =>
      routeResponse.hashCode ^
      route.hashCode ^
      localRouteTotal.hashCode ^
      bridge.hashCode ^
      localBridgeTotal.hashCode ^
      initial.hashCode ^
      localTotal.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UiFieldsCompat &&
          runtimeType == other.runtimeType &&
          routeResponse == other.routeResponse &&
          route == other.route &&
          localRouteTotal == other.localRouteTotal &&
          bridge == other.bridge &&
          localBridgeTotal == other.localBridgeTotal &&
          initial == other.initial &&
          localTotal == other.localTotal;
}
